---
phase: 06-attachments-viewer
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/components/AttachmentViewer/index.tsx
  - src/components/AttachmentViewer/ImageViewer.tsx
  - src/components/AttachmentViewer/TextViewer.tsx
  - src/components/AttachmentViewer/DownloadButton.tsx
  - src/components/TestDetails/TestStepAttachment.tsx
  - src/layout/MainLayout/index.tsx
autonomous: true

must_haves:
  truths:
    - "User can view images in lightbox with zoom capability"
    - "User can view text files with syntax highlighting"
    - "User can download any attachment type"
    - "Clicking attachment in test steps opens appropriate viewer"
  artifacts:
    - path: "src/components/AttachmentViewer/index.tsx"
      provides: "MIME type routing orchestrator"
      exports: ["AttachmentViewer"]
    - path: "src/components/AttachmentViewer/ImageViewer.tsx"
      provides: "Lightbox with zoom plugin"
      exports: ["ImageViewer"]
    - path: "src/components/AttachmentViewer/TextViewer.tsx"
      provides: "Syntax-highlighted text dialog"
      exports: ["TextViewer"]
    - path: "src/components/AttachmentViewer/DownloadButton.tsx"
      provides: "Blob URL download with cleanup"
      exports: ["DownloadButton"]
  key_links:
    - from: "src/components/AttachmentViewer/index.tsx"
      to: "src/store/AttachmentViewerStore.ts"
      via: "useRootStore hook"
      pattern: "attachmentViewerStore"
    - from: "src/components/TestDetails/TestStepAttachment.tsx"
      to: "src/store/AttachmentViewerStore.ts"
      via: "openViewer call"
      pattern: "attachmentViewerStore\\.openViewer"
    - from: "src/layout/MainLayout/index.tsx"
      to: "src/components/AttachmentViewer/index.tsx"
      via: "import and render"
      pattern: "<AttachmentViewer"
---

<objective>
Create AttachmentViewer components (ImageViewer, TextViewer, DownloadButton) and integrate into application.

Purpose: Enables users to view screenshots with zoom, text files with highlighting, and download attachments
Output: Complete attachment viewing system accessible from test steps
</objective>

<execution_context>
@/Users/gda/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-attachments-viewer/06-RESEARCH.md
@.planning/phases/06-attachments-viewer/06-01-SUMMARY.md

@src/store/AttachmentViewerStore.ts
@src/store/index.tsx
@src/schemas/Attachment.schema.ts
@src/components/TestDetails/TestStepAttachment.tsx
@src/layout/MainLayout/index.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AttachmentViewer components (ImageViewer, TextViewer, DownloadButton)</name>
  <files>
    src/components/AttachmentViewer/ImageViewer.tsx,
    src/components/AttachmentViewer/TextViewer.tsx,
    src/components/AttachmentViewer/DownloadButton.tsx
  </files>
  <action>
Create three viewer components following research patterns:

**ImageViewer.tsx** - Lightbox with zoom:
```typescript
import Lightbox from 'yet-another-react-lightbox'
import Zoom from 'yet-another-react-lightbox/plugins/zoom'
import 'yet-another-react-lightbox/styles.css'
import type { Attachment } from '../../schemas/Attachment.schema'

interface ImageViewerProps {
  attachments: Attachment[]
  initialIndex: number
  open: boolean
  onClose: () => void
  onIndexChange: (index: number) => void
}

// Helper to get image source (prefer base64 for static export)
const getImageSource = (attachment: Attachment): string => {
  if (attachment.content) {
    return `data:${attachment.mime_type};base64,${attachment.content}`
  }
  return attachment.file_path
}

export const ImageViewer = ({ attachments, initialIndex, open, onClose, onIndexChange }: ImageViewerProps) => {
  const imageAttachments = attachments.filter(a => a.mime_type?.startsWith('image/'))

  const slides = imageAttachments.map(att => ({
    src: getImageSource(att),
    alt: att.file_name,
  }))

  return (
    <Lightbox
      open={open}
      close={onClose}
      slides={slides}
      index={initialIndex}
      on={{ view: ({ index }) => onIndexChange(index) }}
      plugins={[Zoom]}
      zoom={{
        maxZoomPixelRatio: 3,
        scrollToZoom: true,
      }}
    />
  )
}
```

**TextViewer.tsx** - Syntax-highlighted dialog:
```typescript
import { useState, useEffect } from 'react'
import { Dialog, DialogTitle, DialogContent, DialogActions, Button, Box } from '@mui/material'
import { Highlight, themes } from 'prism-react-renderer'
import type { Attachment } from '../../schemas/Attachment.schema'
import { DownloadButton } from './DownloadButton'

// Map file extensions to Prism language identifiers
const detectLanguage = (fileName: string): string => {
  const ext = fileName.split('.').pop()?.toLowerCase()
  const languageMap: Record<string, string> = {
    'log': 'markup',
    'txt': 'markup',
    'json': 'json',
    'xml': 'xml',
    'html': 'markup',
    'js': 'javascript',
    'ts': 'typescript',
    'py': 'python',
    'java': 'java',
    'sh': 'bash',
    'yml': 'yaml',
    'yaml': 'yaml',
  }
  return languageMap[ext || ''] || 'markup'
}

interface TextViewerProps {
  attachment: Attachment
  open: boolean
  onClose: () => void
}

export const TextViewer = ({ attachment, open, onClose }: TextViewerProps) => {
  const [content, setContent] = useState<string>('')

  useEffect(() => {
    if (!attachment.content) {
      setContent('No content available')
      return
    }

    try {
      const decoded = atob(attachment.content)
      setContent(decoded)
    } catch (error) {
      console.error('Failed to decode attachment content:', error)
      setContent('Error: Failed to decode content')
    }
  }, [attachment])

  const language = detectLanguage(attachment.file_name)

  return (
    <Dialog open={open} onClose={onClose} maxWidth="lg" fullWidth>
      <DialogTitle>{attachment.file_name}</DialogTitle>
      <DialogContent>
        <Highlight theme={themes.github} code={content} language={language}>
          {({ style, tokens, getLineProps, getTokenProps }) => (
            <pre style={{
              ...style,
              padding: 16,
              borderRadius: 4,
              overflow: 'auto',
              maxHeight: '70vh',
              margin: 0,
              fontSize: 13,
            }}>
              {tokens.map((line, i) => (
                <div key={i} {...getLineProps({ line })}>
                  {line.map((token, key) => (
                    <span key={key} {...getTokenProps({ token })} />
                  ))}
                </div>
              ))}
            </pre>
          )}
        </Highlight>
      </DialogContent>
      <DialogActions>
        <DownloadButton attachment={attachment} />
        <Button onClick={onClose}>Close</Button>
      </DialogActions>
    </Dialog>
  )
}
```

**DownloadButton.tsx** - Blob URL with cleanup:
```typescript
import { useState, useEffect } from 'react'
import { Button } from '@mui/material'
import { Download as DownloadIcon } from '@mui/icons-material'
import type { Attachment } from '../../schemas/Attachment.schema'

interface DownloadButtonProps {
  attachment: Attachment
  variant?: 'text' | 'outlined' | 'contained'
}

export const DownloadButton = ({ attachment, variant = 'outlined' }: DownloadButtonProps) => {
  const [downloadUrl, setDownloadUrl] = useState<string | null>(null)

  useEffect(() => {
    if (!attachment.content) {
      // Use file path directly if no base64 content
      setDownloadUrl(attachment.file_path)
      return
    }

    // Create blob from base64 content
    try {
      const binary = atob(attachment.content)
      const bytes = new Uint8Array(binary.length)
      for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i)
      }

      const blob = new Blob([bytes], { type: attachment.mime_type })
      const url = URL.createObjectURL(blob)
      setDownloadUrl(url)

      // CRITICAL: Cleanup to prevent memory leaks
      return () => {
        URL.revokeObjectURL(url)
      }
    } catch (error) {
      console.error('Failed to create download URL:', error)
      setDownloadUrl(null)
    }
  }, [attachment])

  if (!downloadUrl) return null

  return (
    <Button
      variant={variant}
      startIcon={<DownloadIcon />}
      component="a"
      href={downloadUrl}
      download={attachment.file_name}
    >
      Download
    </Button>
  )
}
```

Create directory: `src/components/AttachmentViewer/`
  </action>
  <verify>
`npm run build` passes
All three files exist in src/components/AttachmentViewer/
  </verify>
  <done>ImageViewer with zoom, TextViewer with syntax highlighting, DownloadButton with cleanup created</done>
</task>

<task type="auto">
  <name>Task 2: Create AttachmentViewer orchestrator and integrate into app</name>
  <files>
    src/components/AttachmentViewer/index.tsx,
    src/components/TestDetails/TestStepAttachment.tsx,
    src/layout/MainLayout/index.tsx
  </files>
  <action>
**AttachmentViewer/index.tsx** - Main orchestrator with MIME type routing:
```typescript
import { observer } from 'mobx-react-lite'
import { useRootStore } from '../../store'
import { ImageViewer } from './ImageViewer'
import { TextViewer } from './TextViewer'

/**
 * Main attachment viewer component.
 * Routes to appropriate viewer based on MIME type.
 * Renders at app level, controlled by AttachmentViewerStore.
 */
export const AttachmentViewer = observer(() => {
  const { attachmentViewerStore } = useRootStore()
  const {
    viewerOpen,
    currentAttachment,
    attachmentList,
    currentIndex,
    isImage,
    isText,
  } = attachmentViewerStore

  if (!viewerOpen || !currentAttachment) return null

  // Route to appropriate viewer based on MIME type
  if (isImage) {
    return (
      <ImageViewer
        attachments={attachmentList}
        initialIndex={currentIndex}
        open={viewerOpen}
        onClose={() => attachmentViewerStore.closeViewer()}
        onIndexChange={(index) => attachmentViewerStore.setCurrentIndex(index)}
      />
    )
  }

  if (isText) {
    return (
      <TextViewer
        attachment={currentAttachment}
        open={viewerOpen}
        onClose={() => attachmentViewerStore.closeViewer()}
      />
    )
  }

  // For unsupported types, close viewer (download handled separately)
  attachmentViewerStore.closeViewer()
  return null
})
```

**Update TestStepAttachment.tsx** - Add click handler to open viewer:
1. Import useRootStore
2. Get attachmentViewerStore from hook
3. Add onClick to Chip: `onClick={() => attachmentViewerStore.openViewer(attachment)}`
4. Make inline image clickable to open viewer
5. Keep DownloadButton for non-image/non-text files

Key changes:
- Chip becomes clickable (triggers openViewer)
- Image thumbnail becomes clickable (triggers openViewer)
- Add DownloadButton import and use for all attachment types
- Add cursor: 'pointer' to clickable elements

**Update MainLayout/index.tsx** - Add AttachmentViewer at app level:
1. Import AttachmentViewer from '../components/AttachmentViewer'
2. Add <AttachmentViewer /> after closing Grid container (before ThemeProvider close)

This renders the viewer globally, controlled by AttachmentViewerStore state.
  </action>
  <verify>
`npm run build` passes
`grep -n "AttachmentViewer" src/layout/MainLayout/index.tsx` shows import and render
`grep -n "attachmentViewerStore" src/components/TestDetails/TestStepAttachment.tsx` shows usage
  </verify>
  <done>
AttachmentViewer orchestrates viewers based on MIME type
TestStepAttachment triggers viewer on click
MainLayout renders AttachmentViewer globally
  </done>
</task>

</tasks>

<verification>
- [ ] `npm run build` passes with no errors
- [ ] ImageViewer renders lightbox with zoom capability
- [ ] TextViewer renders dialog with syntax highlighting
- [ ] DownloadButton creates proper download link with cleanup
- [ ] Clicking attachment in TestStepAttachment opens appropriate viewer
- [ ] AttachmentViewer renders at app level (MainLayout)
</verification>

<success_criteria>
- User can click image attachment to view in lightbox with zoom
- User can click text attachment to view with syntax highlighting
- User can download any attachment (button in text viewer, implicit in lightbox)
- All viewers accessible from test step attachments
- Memory properly managed (blob URL cleanup)
- Build passes with no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-attachments-viewer/06-02-SUMMARY.md`
</output>
