---
phase: 46-history-management
plan: 02
type: execute
wave: 2
depends_on: ["46-01"]
files_modified:
  - src/cli/server.ts
  - src/services/ApiDataService.ts
  - src/store/index.tsx
autonomous: true

must_haves:
  truths:
    - "History data available via /api/history endpoint when server runs"
    - "React app automatically loads history in server mode"
    - "History analytics (trends, flakiness) work when history is loaded"
  artifacts:
    - path: "src/cli/server.ts"
      provides: "GET /api/history endpoint"
      contains: "/api/history"
    - path: "src/services/ApiDataService.ts"
      provides: "fetchHistory method for API calls"
      exports: ["fetchHistory"]
    - path: "src/store/index.tsx"
      provides: "Auto-loading history in loadFromApi"
      contains: "loadHistoryFromApi"
  key_links:
    - from: "src/store/index.tsx"
      to: "src/services/ApiDataService.ts"
      via: "ApiDataService.fetchHistory()"
      pattern: "fetchHistory"
    - from: "src/services/ApiDataService.ts"
      to: "/api/history"
      via: "fetch call"
      pattern: "api/history"
    - from: "src/cli/server.ts"
      to: "src/cli/history.ts"
      via: "loadHistory function"
      pattern: "loadHistory"
---

<objective>
Add server API endpoint for history and enable React app to auto-load history data.

Purpose: Allow React app to access history data through the CLI server for analytics features.
Output: /api/history endpoint and automatic history loading in React when running via CLI.
</objective>

<execution_context>
@/Users/gda/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/46-history-management/46-01-SUMMARY.md

@src/cli/server.ts
@src/cli/history.ts
@src/services/ApiDataService.ts
@src/store/index.tsx
@src/store/HistoryStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add /api/history endpoint to server</name>
  <files>src/cli/server.ts</files>
  <action>
Update src/cli/server.ts to serve history data:

1. **Update ServerOptions interface:**
   ```typescript
   export interface ServerOptions {
     reportPath: string
     port?: number
     historyPath?: string  // Add this
   }
   ```

2. **Store historyPath in app settings:**
   ```typescript
   // After app.set('port', port)
   app.set('historyPath', historyPath)
   ```

3. **Add GET /api/history endpoint** (after /api/report):
   ```typescript
   // API endpoint: GET /api/history
   app.get('/api/history', (req: Request, res: Response, next: NextFunction) => {
     try {
       const historyPath = app.get('historyPath') as string | undefined

       if (!historyPath || !existsSync(historyPath)) {
         // Return empty history structure if no history file
         res.json({
           schema_version: '1.0.0',
           runs: [],
           tests: []
         })
         return
       }

       const historyData = JSON.parse(readFileSync(historyPath, 'utf-8'))
       res.json(historyData)
     } catch (err) {
       console.error('Error reading history:', err)
       // Return empty history on error (non-critical)
       res.json({
         schema_version: '1.0.0',
         runs: [],
         tests: []
       })
     }
   })
   ```

Note: Import existsSync and readFileSync from 'fs' if not already imported.
  </action>
  <verify>
`npx tsc --noEmit -p tsconfig.cli.json` passes
  </verify>
  <done>
Server exposes GET /api/history endpoint returning history JSON or empty structure.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update open command to pass historyPath to server</name>
  <files>src/cli/commands/open.ts</files>
  <action>
Update src/cli/commands/open.ts to pass historyPath to createServer:

1. **Update createServer call:**
   ```typescript
   // Determine history path (same logic as before)
   const historyPath = options.history
     ? resolve(options.history)
     : join(resolvedPath, 'qase-report-history.json')

   // Pass to createServer
   const app = createServer({ reportPath: resolvedPath, port, historyPath })
   ```

2. Move the historyPath calculation BEFORE createServer call (currently it's after startServer).

3. Keep the addRunToHistory call where it is (after server starts, before browser opens).
  </action>
  <verify>
`npx tsc --noEmit -p tsconfig.cli.json` passes
  </verify>
  <done>
Server receives historyPath configuration and can serve history via API.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add fetchHistory to ApiDataService and auto-load in store</name>
  <files>src/services/ApiDataService.ts, src/store/index.tsx</files>
  <action>
**Part A: Update src/services/ApiDataService.ts**

1. **Add fetchHistory function:**
   ```typescript
   /**
    * Fetches history data from the server API.
    * Returns null if history is empty or unavailable.
    */
   export async function fetchHistory(): Promise<QaseHistory | null> {
     const response = await fetch('/api/history')
     if (!response.ok) {
       throw new Error(`Failed to fetch history: ${response.status}`)
     }
     const data = await response.json()

     // Return null if history is empty (no runs)
     if (!data.runs || data.runs.length === 0) {
       return null
     }

     return data as QaseHistory
   }
   ```

2. **Add import:**
   ```typescript
   import type { QaseHistory } from '../schemas/QaseHistory.schema'
   ```

**Part B: Update src/store/index.tsx**

1. **Update loadFromApi method:**
   After loading report data and before setting isApiLoading = false, add:
   ```typescript
   // Load history if available
   try {
     const historyData = await fetchHistory()
     if (historyData) {
       runInAction(() => {
         this.historyStore.history = historyData
         this.historyStore.isHistoryLoaded = true
       })
     }
   } catch (historyError) {
     // History loading is optional, just log warning
     console.warn('Could not load history:', historyError)
   }
   ```

2. **Add import:**
   ```typescript
   import { fetchHistory } from '../services/ApiDataService'
   ```

This ensures history is loaded automatically when React app runs in server mode, enabling analytics features (trends, flakiness, stability) without manual file upload.
  </action>
  <verify>
1. `npx tsc --noEmit` passes (full project)
2. `npm run build` succeeds
  </verify>
  <done>
React app auto-loads history in server mode, enabling analytics features immediately.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles for both CLI and React app
2. Full build: `npm run build`
3. Integration test:
   ```bash
   # Build CLI
   npm run build:cli

   # Create test data with history
   mkdir -p /tmp/test-results/results
   echo '{"execution":{"start_time":1707750000000,"end_time":1707750060000,"duration":60000,"cumulative_duration":60000},"stats":{"total":2,"passed":1,"failed":1,"skipped":0},"results":[],"threads":["main"],"suites":["Suite A"],"host_data":{"node":"20.0.0","system":"Darwin","release":"24.0.0","version":"Darwin Kernel","machine":"arm64"}}' > /tmp/test-results/run.json

   # Run open command
   node dist/cli/index.js open /tmp/test-results --port 3001 &

   # Test API endpoints
   curl http://localhost:3001/api/report
   curl http://localhost:3001/api/history

   # Kill server
   kill %1
   ```
4. Verify React app loads history by opening browser and checking analytics tab shows history data
</verification>

<success_criteria>
- GET /api/history returns history JSON or empty structure
- React app loads history automatically in server mode
- Analytics features (trends, flakiness) work with loaded history
- History loading failure is non-critical (warning only, app still works)
</success_criteria>

<output>
After completion, create `.planning/phases/46-history-management/46-02-SUMMARY.md`
</output>
