---
phase: 45-local-server
plan: 02
type: execute
wave: 2
depends_on: ["45-01"]
files_modified:
  - src/cli/index.ts
  - src/cli/commands/open.ts
  - src/store/index.tsx
  - src/services/ApiDataService.ts
autonomous: false

must_haves:
  truths:
    - "User runs `qase-report open ./results` and server starts on port 3000"
    - "Browser opens automatically showing React app with report data"
    - "User can specify custom port with `--port 8080`"
    - "User can disable auto-open with `--no-open`"
    - "Server shuts down cleanly on Ctrl+C with exit message"
  artifacts:
    - path: "src/cli/commands/open.ts"
      provides: "Open command implementation with CLI options"
      min_lines: 40
      exports: ["registerOpenCommand"]
    - path: "src/services/ApiDataService.ts"
      provides: "Service for fetching report data from API"
      min_lines: 30
      exports: ["ApiDataService"]
  key_links:
    - from: "src/cli/commands/open.ts"
      to: "src/cli/server.ts"
      via: "import and call createServer/startServer"
      pattern: "import.*server"
    - from: "src/store/index.tsx"
      to: "src/services/ApiDataService.ts"
      via: "loadFromApi method"
      pattern: "ApiDataService|loadFromApi"
    - from: "src/cli/commands/open.ts"
      to: "open"
      via: "open package for browser"
      pattern: "import open|open\\("
---

<objective>
Implement the CLI open command and React app API data loading

Purpose: Complete the local server feature by wiring CLI to server and enabling React app to load data from API
Output: Fully functional `qase-report open` command with all options working
</objective>

<execution_context>
@/Users/gda/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/45-local-server/45-01-SUMMARY.md
@src/cli/index.ts
@src/cli/server.ts
@src/store/index.tsx
@src/services/FileLoaderService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create open command module</name>
  <files>src/cli/commands/open.ts, src/cli/index.ts</files>
  <action>
Create `src/cli/commands/open.ts` with:

1. **Command registration function** `registerOpenCommand(program: Command)`:
   - Takes Commander program instance
   - Adds `open <path>` command with description "Serve report in browser"

2. **Command options**:
   - `--port <number>` or `-p <number>`: Port number (default: 3000)
   - `--no-open`: Disable automatic browser opening (flag, default: open is true)

3. **Command action handler**:
   - Validate path exists and contains run.json (use fs.existsSync, fs.accessSync)
   - If validation fails, print error and exit with code 1
   - Import and call createServer from ../server.ts
   - Start server with startServer
   - If open flag is true (not --no-open), use `open` package to open browser at `http://localhost:{port}`
   - Print startup message: "Serving report from {path}"
   - Print URL: "Open http://localhost:{port} in your browser"
   - Keep process running (server keeps event loop alive)

4. **Update src/cli/index.ts**:
   - Import registerOpenCommand from ./commands/open.ts
   - Remove the placeholder open command
   - Call registerOpenCommand(program)

Use dynamic import for server.ts to avoid bundling issues: `const { createServer, startServer } = await import('../server.js')`
  </action>
  <verify>
1. Build CLI: `npm run build:cli`
2. Run: `node dist/cli/index.js open --help` - shows options
3. Run with invalid path: `node dist/cli/index.js open /nonexistent` - shows error and exits
  </verify>
  <done>
Open command implemented with --port and --no-open options, path validation, server startup, and browser opening.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create API data loading service</name>
  <files>src/services/ApiDataService.ts</files>
  <action>
Create `src/services/ApiDataService.ts` with:

1. **API response types**:
   ```typescript
   interface ApiReportResponse {
     run: unknown  // Will be validated by schema
     results: unknown[]
     attachmentsPath: string
   }
   ```

2. **ApiDataService class**:
   - Constructor takes optional baseUrl (default: window.location.origin)
   - `async fetchReport(): Promise<ApiReportResponse>`:
     - Fetch GET /api/report
     - Parse JSON response
     - Throw error if response not ok
   - `getAttachmentUrl(filename: string): string`:
     - Returns full URL for attachment: `{baseUrl}/api/attachments/{filename}`

3. **Server mode detection**:
   - Export `isServerMode(): boolean` function
   - Returns true if `window.__QASE_SERVER_MODE__` is set OR if URL has `?server=true` param
   - This allows React app to detect when running via CLI server vs static file
  </action>
  <verify>
1. TypeScript compiles: `npm run build`
2. File exists with exported class and function
  </verify>
  <done>
ApiDataService created with fetchReport method and server mode detection function.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate API loading into store</name>
  <files>src/store/index.tsx, src/main.tsx</files>
  <action>
Update `src/store/index.tsx`:

1. Add import for ApiDataService and isServerMode
2. Add new method `loadFromApi()`:
   - Create ApiDataService instance
   - Call fetchReport()
   - Validate run data with QaseRunSchema (same as loadReport)
   - Validate each result with QaseTestResultSchema
   - Populate reportStore.runData
   - Populate testResultsStore.testResults Map
   - Store attachmentsPath for later use
   - Handle errors appropriately

3. Add `attachmentsBasePath: string | null = null` observable property
   - Used by attachments to construct URLs when in server mode

Update `src/main.tsx` or create new auto-load hook:

1. In App.tsx or MainLayout, add useEffect that:
   - Checks isServerMode()
   - If true, calls rootStore.loadFromApi()
   - Shows loading state while fetching
   - This triggers automatic data loading when served by CLI

Update AttachmentsStore to use API URLs when in server mode:
- Check if attachmentsBasePath is set
- If set, use ApiDataService.getAttachmentUrl() for attachment URLs
- Otherwise use existing File API blob URLs
  </action>
  <verify>
1. `npm run build` completes without errors
2. Code review: loadFromApi method exists and handles API response
3. Server mode detection integrated into app startup
  </verify>
  <done>
Store can load data from API, auto-loads when in server mode, attachments work via API URLs.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 4: Verify complete local server functionality</name>
  <what-built>
Complete local server functionality:
- CLI `open` command with --port and --no-open options
- Express server serving React app and data API
- React app auto-loading data from API when served
- Graceful shutdown on Ctrl+C
  </what-built>
  <how-to-verify>
1. Build the project: `npm run build`
2. Create test data (or use existing qase-report results folder)
3. Run: `node dist/cli/index.js open ./path/to/results`
4. Expected: Server starts, browser opens, report displays with data
5. Test custom port: `node dist/cli/index.js open ./path/to/results --port 8080`
6. Test no-open: `node dist/cli/index.js open ./path/to/results --no-open`
7. Test shutdown: Press Ctrl+C, expect "Server stopped" message
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. `npm run build` completes (both React app and CLI)
2. `qase-report open --help` shows port and no-open options
3. Server starts and serves React app on correct port
4. Browser opens automatically (unless --no-open)
5. React app displays report data loaded from API
6. Ctrl+C cleanly stops server
</verification>

<success_criteria>
- User can run `qase-report open ./results` and see report in browser
- Custom port works with --port option
- Auto-open can be disabled with --no-open
- Server stops cleanly on Ctrl+C
- All phase success criteria from ROADMAP.md satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/45-local-server/45-02-SUMMARY.md`
</output>
