---
phase: 03-test-list-navigation
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/components/TestList/index.tsx
  - src/components/TestList/TestListItem.tsx
  - src/components/TestList/TestListFilters.tsx
  - src/components/TestList/TestListSearch.tsx
  - src/components/TestList/SuiteGroup.tsx
  - src/components/TestList/statusIcon.tsx
  - src/layout/MainLayout/index.tsx
autonomous: true

must_haves:
  truths:
    - "User sees all tests displayed in a list with status icons"
    - "User can click status filter chips and list updates to show only matching tests"
    - "User can type in search box and list updates to show only matching tests"
    - "User sees tests grouped by suite with collapsible sections"
    - "User can click a test to select it (selectedTestId updates)"
  artifacts:
    - path: "src/components/TestList/index.tsx"
      provides: "Main TestList component with filters, search, and grouped list"
      exports: ["TestList"]
    - path: "src/components/TestList/TestListItem.tsx"
      provides: "Individual test item with status icon and click handler"
      exports: ["TestListItem"]
    - path: "src/components/TestList/TestListFilters.tsx"
      provides: "Status filter chips (passed/failed/skipped/broken)"
      exports: ["TestListFilters"]
    - path: "src/components/TestList/TestListSearch.tsx"
      provides: "Debounced search input"
      exports: ["TestListSearch"]
    - path: "src/components/TestList/SuiteGroup.tsx"
      provides: "Collapsible suite container"
      exports: ["SuiteGroup"]
    - path: "src/components/TestList/statusIcon.tsx"
      provides: "Status icon helper function"
      exports: ["getStatusIcon"]
    - path: "src/layout/MainLayout/index.tsx"
      provides: "Layout with TestList integrated"
      contains: "TestList"
  key_links:
    - from: "TestListFilters"
      to: "testResultsStore.toggleStatusFilter"
      via: "Chip onClick calls store action"
      pattern: "toggleStatusFilter"
    - from: "TestListSearch"
      to: "testResultsStore.setSearchQuery"
      via: "Debounced useEffect calls store action"
      pattern: "setSearchQuery"
    - from: "TestList"
      to: "testResultsStore.filteredResults"
      via: "Component reads computed getter"
      pattern: "filteredResults"
    - from: "TestListItem"
      to: "selectTest"
      via: "ListItemButton onClick calls store action"
      pattern: "selectTest"
    - from: "SuiteGroup"
      to: "Collapse"
      via: "MUI Collapse controls visibility"
      pattern: "Collapse.*in=\\{open\\}"
---

<objective>
Create TestList UI components for browsing, filtering, searching, and navigating tests.

Purpose: Users need to see all tests, filter by status, search by name, see suite grouping, and click to select a test. This completes the "browse, filter, search tests" phase goal.

Output: TestList component folder with 6 files, MainLayout updated to render TestList.
</objective>

<execution_context>
@/Users/gda/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-test-list-navigation/03-RESEARCH.md
@.planning/phases/03-test-list-navigation/03-01-SUMMARY.md

@src/store/index.tsx
@src/store/TestResultsStore.ts
@src/schemas/QaseTestResult.schema.ts
@src/components/Dashboard/index.tsx
@src/layout/MainLayout/index.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TestList helper and item components</name>
  <files>
    src/components/TestList/statusIcon.tsx
    src/components/TestList/TestListItem.tsx
  </files>
  <action>
Create the TestList component folder and foundational components.

**File: src/components/TestList/statusIcon.tsx**
Status icon helper function:

```typescript
import { CheckCircle, Error, Warning, DoNotDisturb } from '@mui/icons-material'

export const getStatusIcon = (status: string) => {
  switch (status) {
    case 'passed':
      return <CheckCircle color="success" />
    case 'failed':
      return <Error color="error" />
    case 'broken':
      return <Warning color="warning" />
    case 'skipped':
    default:
      return <DoNotDisturb color="disabled" />
  }
}
```

**File: src/components/TestList/TestListItem.tsx**
Memoized list item component:

```typescript
import { memo } from 'react'
import { ListItem, ListItemButton, ListItemIcon, ListItemText } from '@mui/material'
import type { QaseTestResult } from '../../schemas/QaseTestResult.schema'
import { getStatusIcon } from './statusIcon'

interface TestListItemProps {
  test: QaseTestResult
  onSelect: (id: string) => void
}

export const TestListItem = memo(({ test, onSelect }: TestListItemProps) => {
  const handleClick = () => onSelect(test.id)

  // Format duration: if > 1000ms show as seconds
  const duration = test.execution.duration
  const durationText = duration >= 1000
    ? `${(duration / 1000).toFixed(1)}s`
    : `${duration}ms`

  return (
    <ListItem disablePadding>
      <ListItemButton onClick={handleClick}>
        <ListItemIcon sx={{ minWidth: 36 }}>
          {getStatusIcon(test.execution.status)}
        </ListItemIcon>
        <ListItemText
          primary={test.title}
          secondary={durationText}
          primaryTypographyProps={{ noWrap: true }}
        />
      </ListItemButton>
    </ListItem>
  )
})
```

Use `memo()` for performance - prevents re-render when parent list re-renders but this item's props haven't changed.
  </action>
  <verify>
Files exist and TypeScript compiles:
```bash
ls src/components/TestList/statusIcon.tsx src/components/TestList/TestListItem.tsx
npx tsc --noEmit
```
  </verify>
  <done>
statusIcon.tsx exports getStatusIcon helper.
TestListItem.tsx exports memoized TestListItem component with status icon, title, and duration.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create filter, search, and suite group components</name>
  <files>
    src/components/TestList/TestListFilters.tsx
    src/components/TestList/TestListSearch.tsx
    src/components/TestList/SuiteGroup.tsx
  </files>
  <action>
**File: src/components/TestList/TestListFilters.tsx**
Status filter chips with MobX observer:

```typescript
import { Box, Chip } from '@mui/material'
import { observer } from 'mobx-react-lite'
import { useRootStore } from '../../store'

const statuses = [
  { value: 'passed', label: 'Passed', color: 'success' as const },
  { value: 'failed', label: 'Failed', color: 'error' as const },
  { value: 'broken', label: 'Broken', color: 'warning' as const },
  { value: 'skipped', label: 'Skipped', color: 'default' as const },
]

export const TestListFilters = observer(() => {
  const { testResultsStore } = useRootStore()
  const { statusFilters, toggleStatusFilter } = testResultsStore

  return (
    <Box sx={{ display: 'flex', gap: 1, flexWrap: 'wrap' }}>
      {statuses.map((status) => (
        <Chip
          key={status.value}
          label={status.label}
          color={status.color}
          variant={statusFilters.has(status.value) ? 'filled' : 'outlined'}
          onClick={() => toggleStatusFilter(status.value)}
          size="small"
        />
      ))}
    </Box>
  )
})
```

**File: src/components/TestList/TestListSearch.tsx**
Debounced search input (300ms):

```typescript
import { useState, useEffect } from 'react'
import { TextField, InputAdornment } from '@mui/material'
import { Search } from '@mui/icons-material'
import { observer } from 'mobx-react-lite'
import { useRootStore } from '../../store'

export const TestListSearch = observer(() => {
  const { testResultsStore } = useRootStore()
  const [localQuery, setLocalQuery] = useState('')

  // Debounce: only update store after 300ms of no typing
  useEffect(() => {
    const timeoutId = setTimeout(() => {
      testResultsStore.setSearchQuery(localQuery)
    }, 300)

    return () => clearTimeout(timeoutId)
  }, [localQuery, testResultsStore])

  return (
    <TextField
      fullWidth
      size="small"
      placeholder="Search tests..."
      value={localQuery}
      onChange={(e) => setLocalQuery(e.target.value)}
      InputProps={{
        startAdornment: (
          <InputAdornment position="start">
            <Search color="action" />
          </InputAdornment>
        ),
      }}
    />
  )
})
```

**File: src/components/TestList/SuiteGroup.tsx**
Collapsible suite container:

```typescript
import { useState } from 'react'
import { List, ListItemButton, ListItemText, Collapse, Box } from '@mui/material'
import { ExpandLess, ExpandMore } from '@mui/icons-material'
import type { QaseTestResult } from '../../schemas/QaseTestResult.schema'
import { TestListItem } from './TestListItem'

interface SuiteGroupProps {
  suiteTitle: string
  tests: QaseTestResult[]
  onSelectTest: (id: string) => void
}

export const SuiteGroup = ({ suiteTitle, tests, onSelectTest }: SuiteGroupProps) => {
  const [open, setOpen] = useState(true) // Start expanded

  return (
    <>
      <ListItemButton onClick={() => setOpen(!open)} sx={{ bgcolor: 'action.hover' }}>
        <ListItemText
          primary={suiteTitle}
          secondary={`${tests.length} test${tests.length !== 1 ? 's' : ''}`}
        />
        {open ? <ExpandLess /> : <ExpandMore />}
      </ListItemButton>
      <Collapse in={open} timeout="auto" unmountOnExit>
        <List component="div" disablePadding>
          <Box sx={{ pl: 2 }}>
            {tests.map((test) => (
              <TestListItem
                key={test.id}
                test={test}
                onSelect={onSelectTest}
              />
            ))}
          </Box>
        </List>
      </Collapse>
    </>
  )
}
```

Start expanded (`useState(true)`) so users see tests immediately. Use `unmountOnExit` for Collapse to improve performance.
  </action>
  <verify>
Files exist and TypeScript compiles:
```bash
ls src/components/TestList/TestListFilters.tsx src/components/TestList/TestListSearch.tsx src/components/TestList/SuiteGroup.tsx
npx tsc --noEmit
```
  </verify>
  <done>
TestListFilters.tsx exports observer component with 4 status filter chips.
TestListSearch.tsx exports observer component with debounced search input.
SuiteGroup.tsx exports collapsible suite container with test count.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create main TestList component and integrate into MainLayout</name>
  <files>
    src/components/TestList/index.tsx
    src/layout/MainLayout/index.tsx
  </files>
  <action>
**File: src/components/TestList/index.tsx**
Main TestList component that orchestrates everything:

```typescript
import { Box, List, Typography, Paper } from '@mui/material'
import { observer } from 'mobx-react-lite'
import { useRootStore } from '../../store'
import { TestListFilters } from './TestListFilters'
import { TestListSearch } from './TestListSearch'
import { SuiteGroup } from './SuiteGroup'
import type { QaseTestResult } from '../../schemas/QaseTestResult.schema'

// Group tests by top-level suite
const groupBySuite = (tests: QaseTestResult[]) => {
  const grouped = new Map<string, QaseTestResult[]>()

  for (const test of tests) {
    const suiteTitle = test.relations?.suite?.data?.[0]?.title || 'Uncategorized'

    if (!grouped.has(suiteTitle)) {
      grouped.set(suiteTitle, [])
    }
    grouped.get(suiteTitle)!.push(test)
  }

  return grouped
}

export const TestList = observer(() => {
  const { testResultsStore, selectTest } = useRootStore()
  const { filteredResults, resultsList, activeFilterCount } = testResultsStore

  // Early return if no tests loaded
  if (resultsList.length === 0) {
    return (
      <Typography variant="body2" color="text.secondary">
        No tests loaded. Load a report to view tests.
      </Typography>
    )
  }

  const grouped = groupBySuite(filteredResults)

  return (
    <Paper sx={{ p: 2 }}>
      <Typography variant="h6" gutterBottom>
        Tests
      </Typography>

      {/* Filters and search */}
      <Box sx={{ mb: 2, display: 'flex', flexDirection: 'column', gap: 2 }}>
        <TestListSearch />
        <TestListFilters />
      </Box>

      {/* Filter summary */}
      <Typography variant="body2" color="text.secondary" sx={{ mb: 1 }}>
        Showing {filteredResults.length} of {resultsList.length} tests
        {activeFilterCount > 0 && ` (${activeFilterCount} filter${activeFilterCount !== 1 ? 's' : ''} active)`}
      </Typography>

      {/* Empty state when filters match nothing */}
      {filteredResults.length === 0 && resultsList.length > 0 && (
        <Typography variant="body2" color="text.secondary" sx={{ py: 2, textAlign: 'center' }}>
          No tests match current filters.
        </Typography>
      )}

      {/* Grouped test list */}
      <List sx={{ maxHeight: 'calc(100vh - 400px)', overflow: 'auto' }}>
        {Array.from(grouped.entries()).map(([suite, tests]) => (
          <SuiteGroup
            key={suite}
            suiteTitle={suite}
            tests={tests}
            onSelectTest={selectTest}
          />
        ))}
      </List>
    </Paper>
  )
})
```

**File: src/layout/MainLayout/index.tsx**
Update to include TestList below Dashboard:

```typescript
import { observer } from 'mobx-react-lite'
import { Button, Grid, Box } from '@mui/material'
import { useRootStore } from '../../store'
import { Sidebar } from '../../components/Sidebar'
import { LoadReportButton } from '../../components/LoadReportButton'
import { Dashboard } from '../../components/Dashboard'
import { TestList } from '../../components/TestList'

export const MainLayout = observer(() => {
  const { isDockOpen, closeDock, openDock, reportStore } = useRootStore()

  return (
    <Grid
      container
      spacing={2}
      component={'main'}
      sx={{ height: 'calc(100vh - 48px)', width: '100vw', p: 2 }}
    >
      <Grid item xs={10}>
        <Box sx={{ display: 'flex', gap: 2, mb: 2 }}>
          <LoadReportButton />
          <Button type={'button'} onClick={openDock}>
            Open sidebar
          </Button>
        </Box>
        <Dashboard />
        {/* Show TestList only when report is loaded */}
        {reportStore.runData && (
          <Box sx={{ mt: 3 }}>
            <TestList />
          </Box>
        )}
      </Grid>
      <Grid item xs={2}></Grid>
      <Sidebar isOpen={isDockOpen} onClose={closeDock}>
        Hello from sidebar
      </Sidebar>
    </Grid>
  )
})
```

Note: Added `reportStore` to destructuring to conditionally render TestList only when a report is loaded.
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit`
2. Dev server runs: `npm run dev`
3. Manual verification:
   - Load a report
   - See Dashboard stats AND TestList below it
   - See tests grouped by suite
   - Click filter chips - list updates
   - Type in search - list updates after 300ms
   - Click a test - selectedTestId changes (check in console: `store.selectedTestId`)
  </verify>
  <done>
TestList/index.tsx exports main TestList component with filters, search, and suite grouping.
MainLayout shows Dashboard + TestList when report is loaded.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. `npm run dev` starts without errors
2. Load a Qase report JSON
3. Dashboard shows stats (existing)
4. TestList appears below Dashboard
5. Tests are grouped by suite with collapsible sections
6. Each test shows status icon (CheckCircle/Error/Warning/DoNotDisturb)
7. Click "Passed" chip - only passed tests shown
8. Click "Passed" again - all tests shown
9. Type in search box - list filters after typing stops
10. Click any test - `store.selectedTestId` updates (Phase 4 will use this)
11. Empty filter results show "No tests match current filters" message
</verification>

<success_criteria>
1. TestList component renders all tests with status icons
2. TestListFilters allows filtering by passed/failed/skipped/broken
3. TestListSearch filters tests by name with 300ms debounce
4. SuiteGroup shows collapsible suite containers
5. Clicking test calls selectTest and updates selectedTestId
6. MainLayout shows Dashboard + TestList when report loaded
7. Filter summary shows "Showing X of Y tests"
8. Empty state handled with message
</success_criteria>

<output>
After completion, create `.planning/phases/03-test-list-navigation/03-02-SUMMARY.md`
</output>
