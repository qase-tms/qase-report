---
phase: 10-flakiness-detection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/store/AnalyticsStore.ts
  - src/types/flakiness.ts
autonomous: true

must_haves:
  truths:
    - "System detects flaky tests using status changes AND error consistency"
    - "Detection requires minimum 5 runs to avoid false positives"
    - "Algorithm considers error message patterns, not just status changes"
  artifacts:
    - path: "src/types/flakiness.ts"
      provides: "FlakinessResult type definition"
      exports: ["FlakinessResult", "StabilityStatus"]
    - path: "src/store/AnalyticsStore.ts"
      provides: "Flakiness detection algorithm"
      contains: "getFlakinessScore"
  key_links:
    - from: "src/store/AnalyticsStore.ts"
      to: "src/store/HistoryStore.ts"
      via: "getTestHistory(signature)"
      pattern: "this\\.root\\.historyStore\\.getTestHistory"
---

<objective>
Implement multi-factor flakiness detection algorithm in AnalyticsStore

Purpose: Provide accurate flakiness detection that avoids false positives by analyzing both status changes and error message consistency across historical runs.

Output: FlakinessResult type and getFlakinessScore() method that returns flakiness percentage and stability status for any test signature.
</objective>

<execution_context>
@/Users/gda/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/store/AnalyticsStore.ts
@src/store/HistoryStore.ts
@src/schemas/QaseHistory.schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create flakiness types</name>
  <files>src/types/flakiness.ts</files>
  <action>
Create type definitions for flakiness detection:

```typescript
/**
 * Stability status categories for test health.
 * - flaky: Test alternates between pass/fail inconsistently
 * - stable: Test consistently passes or fails
 * - new_failure: Test recently started failing after being stable
 * - insufficient_data: Less than MIN_RUNS (5) available
 */
export type StabilityStatus = 'flaky' | 'stable' | 'new_failure' | 'insufficient_data'

/**
 * Result of flakiness analysis for a single test.
 */
export interface FlakinessResult {
  /** Flakiness percentage (0-100) - "flaky in X of Y runs" */
  flakinessPercent: number
  /** Stability classification */
  status: StabilityStatus
  /** Number of runs analyzed */
  totalRuns: number
  /** Number of status transitions (pass->fail or fail->pass) */
  statusChanges: number
  /** Whether error messages are consistent across failures */
  hasConsistentErrors: boolean
  /** Minimum runs required for accurate detection */
  minRunsRequired: number
}
```

Export MIN_RUNS constant as 5 per FLKY-04 requirement.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>FlakinessResult and StabilityStatus types exported from src/types/flakiness.ts</done>
</task>

<task type="auto">
  <name>Task 2: Implement flakiness detection algorithm</name>
  <files>src/store/AnalyticsStore.ts</files>
  <action>
Add getFlakinessScore(signature: string): FlakinessResult method to AnalyticsStore.

Algorithm (multi-factor per FLKY-01, avoids naive detection pitfall):

1. **Get history**: Call `this.root.historyStore.getTestHistory(signature)` to get HistoricalTestRunData[]

2. **Check minimum runs** (FLKY-04): If runs.length < 5, return `{ status: 'insufficient_data', flakinessPercent: 0, totalRuns: runs.length, ... }`

3. **Count status transitions**: Iterate runs chronologically, count times status changes from passed/failed to opposite. Skip skipped/broken runs in transition counting (they don't indicate flakiness).

4. **Analyze error consistency**: For all failed runs, extract error_message. Group by first 100 chars (normalize). If >80% of failures have same error pattern, mark hasConsistentErrors = true (likely real bug, not flaky).

5. **Calculate flakiness score**:
   - Base: `statusChanges / (totalRuns - 1)` - proportion of possible transitions that occurred
   - Penalty: If hasConsistentErrors, multiply by 0.5 (consistent errors = less likely flaky)
   - Final: `Math.round(baseScore * 100)` as percentage

6. **Determine status**:
   - `insufficient_data`: totalRuns < 5
   - `flaky`: flakinessPercent >= 20 (20%+ transitions = flaky)
   - `new_failure`: Last run failed AND previous 3+ runs passed AND flakinessPercent < 20
   - `stable`: Otherwise

Import types from `../types/flakiness` (FlakinessResult, StabilityStatus, MIN_RUNS).

Do NOT make this a computed property - it's a method called per-test, not a store-wide computation.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>getFlakinessScore returns FlakinessResult with multi-factor analysis including error consistency</done>
</task>

<task type="auto">
  <name>Task 3: Add flakyTests computed property</name>
  <files>src/store/AnalyticsStore.ts</files>
  <action>
Add computed property `flakyTests` that returns array of flaky test signatures.

```typescript
/**
 * Returns signatures of all tests classified as flaky.
 * Useful for filtering test list to show only flaky tests.
 */
get flakyTests(): string[] {
  const history = this.root.historyStore.history
  if (!history) return []

  return history.tests
    .map(t => t.signature)
    .filter(sig => this.getFlakinessScore(sig).status === 'flaky')
}
```

Also add `flakyTestCount` computed for dashboard display:

```typescript
get flakyTestCount(): number {
  return this.flakyTests.length
}
```

These are computed properties (reactive) unlike getFlakinessScore (imperative method).
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>flakyTests computed returns array of flaky test signatures, flakyTestCount returns count</done>
</task>

</tasks>

<verification>
After all tasks:
1. `npx tsc --noEmit` passes
2. AnalyticsStore has getFlakinessScore method
3. Types exported from src/types/flakiness.ts
4. Algorithm uses 5-run minimum (FLKY-04)
5. Algorithm considers error_message consistency (FLKY-01)
</verification>

<success_criteria>
- FlakinessResult type defines flakinessPercent, status, totalRuns, statusChanges, hasConsistentErrors
- getFlakinessScore returns insufficient_data when runs < 5
- getFlakinessScore considers error message patterns for consistency
- flakyTests computed returns signatures of flaky tests
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/10-flakiness-detection/10-01-SUMMARY.md`
</output>
