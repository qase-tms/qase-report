---
phase: 01-data-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/store/ReportStore.ts
  - src/store/TestResultsStore.ts
  - src/store/AttachmentsStore.ts
  - src/store/index.tsx
autonomous: true

must_haves:
  truths:
    - "RootStore has child stores for report data domains"
    - "ReportStore can load and validate run.json"
    - "TestResultsStore can load multiple result files with progress tracking"
    - "AttachmentsStore registers attachment files and provides URLs"
    - "Stores expose loading states and errors for UI consumption"
  artifacts:
    - path: "src/store/ReportStore.ts"
      provides: "MobX store for run.json data with loading/error states"
      exports: ["ReportStore"]
      min_lines: 60
    - path: "src/store/TestResultsStore.ts"
      provides: "MobX store for test results collection with progress"
      exports: ["TestResultsStore"]
      min_lines: 50
    - path: "src/store/AttachmentsStore.ts"
      provides: "MobX store for attachment blob URL registry"
      exports: ["AttachmentsStore"]
      min_lines: 40
    - path: "src/store/index.tsx"
      provides: "Updated RootStore with child domain stores"
      exports: ["RootStore", "useRootStore", "RootStoreProvider"]
      contains: "reportStore"
  key_links:
    - from: "src/store/ReportStore.ts"
      to: "src/services/FileLoaderService.ts"
      via: "service instantiation and method calls"
      pattern: "new FileLoaderService\\(\\)|fileLoader\\."
    - from: "src/store/ReportStore.ts"
      to: "src/services/ParserService.ts"
      via: "JSON parsing with schema validation"
      pattern: "parserService\\.parseJSON"
    - from: "src/store/index.tsx"
      to: "src/store/ReportStore.ts"
      via: "RootStore constructor instantiates child stores"
      pattern: "new ReportStore\\(this\\)"
---

<objective>
Implement MobX domain stores for Qase Report data management with reactive state updates.

Purpose: Create observable stores following existing RootStore pattern to hold run metadata, test results collection, and attachment URLs. Stores coordinate with services from Plan 01 to load and validate data, exposing loading/error states for UI.

Output: Three domain stores integrated into RootStore, ready for React component consumption via useRootStore hook.
</objective>

<execution_context>
@/Users/gda/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-data-foundation/01-RESEARCH.md
@.planning/phases/01-data-foundation/01-01-SUMMARY.md
@src/store/index.tsx
@src/services/FileLoaderService.ts
@src/services/ParserService.ts
@src/services/AttachmentService.ts
@src/schemas/QaseRun.schema.ts
@src/schemas/QaseTestResult.schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ReportStore</name>
  <files>
    src/store/ReportStore.ts
  </files>
  <action>
Create ReportStore class for run.json data management:

**Class structure:**
```typescript
export class ReportStore {
  runData: QaseRun | null = null
  isLoading = false
  error: string | null = null

  constructor(public root: RootStore)

  async loadRun(file: File): Promise<void>

  // Computed values
  get totalTests(): number
  get passRate(): number
}
```

**Implementation details:**
- Import QaseRun type and QaseRunSchema from schemas
- Use `makeAutoObservable(this)` in constructor (existing pattern from RootStore)
- Pass root store reference in constructor: `constructor(public root: RootStore)`
- `loadRun` method:
  - Set isLoading = true, clear error
  - Create ParserService instance
  - Read file with `file.text()` method
  - Parse with `parserService.parseJSON(text, QaseRunSchema)`
  - Wrap state mutations in `runInAction()` from mobx
  - Store validated data in runData
  - Catch errors and store in error property
  - Set isLoading = false in finally block
- `totalTests` computed: return runData?.stats.total || 0
- `passRate` computed: calculate percentage from runData?.stats.passed / total

Follow research patterns from RESEARCH.md "Pattern 1: MobX Domain Store Pattern" and "Code Examples > MobX Store Integration".

Use existing RootStore pattern from src/store/index.tsx as reference (makeAutoObservable, root reference).
  </action>
  <verify>
Run TypeScript compiler:
```bash
npx tsc --noEmit
```

Check file exports ReportStore:
```bash
grep "export class ReportStore" src/store/ReportStore.ts
```

Verify makeAutoObservable usage:
```bash
grep "makeAutoObservable" src/store/ReportStore.ts
```
  </verify>
  <done>
- ReportStore.ts exists and exports ReportStore class
- Class has observable properties: runData, isLoading, error
- Class has loadRun async method using ParserService and QaseRunSchema
- Class has computed values: totalTests, passRate
- Uses makeAutoObservable in constructor
- Uses runInAction for async state mutations
- TypeScript compilation succeeds
  </done>
</task>

<task type="auto">
  <name>Task 2: Create TestResultsStore and AttachmentsStore</name>
  <files>
    src/store/TestResultsStore.ts
    src/store/AttachmentsStore.ts
  </files>
  <action>
Create TestResultsStore for test results collection:

**src/store/TestResultsStore.ts:**
```typescript
export class TestResultsStore {
  testResults = new Map<string, QaseTestResult>()
  isLoading = false
  loadingProgress = { current: 0, total: 0 }
  error: string | null = null

  constructor(public root: RootStore)

  async loadResults(files: File[]): Promise<void>

  get resultsList(): QaseTestResult[]
}
```
- Import QaseTestResult type and TestResultSchema
- Use makeAutoObservable in constructor
- `loadResults` method:
  - Set isLoading = true, loadingProgress.total = files.length
  - Loop through files with for...of
  - For each file: read text, parse with ParserService + TestResultSchema
  - Store in Map: `testResults.set(result.id, result)`
  - Increment loadingProgress.current with runInAction
  - Catch errors per-file but continue (don't break entire load)
  - Collect errors in array if needed
  - Set isLoading = false in finally
- `resultsList` computed: return `Array.from(this.testResults.values())`

Create AttachmentsStore for blob URL management:

**src/store/AttachmentsStore.ts:**
```typescript
export class AttachmentsStore {
  private attachmentUrls = new Map<string, string>()

  constructor(public root: RootStore)

  registerAttachment(file: File): string
  getAttachmentUrl(id: string): string | undefined
  cleanup(): void
}
```
- Use makeAutoObservable in constructor
- `registerAttachment`: Extract ID from filename (format: "{uuid}-filename.ext"), create blob URL with URL.createObjectURL, store in Map, return URL
- `getAttachmentUrl`: return URL from Map
- `cleanup`: revoke all URLs with URL.revokeObjectURL, clear Map

Follow research patterns from RESEARCH.md "Pattern 4: Blob URL Management for Attachments" and "Code Examples > MobX Store Integration".

CRITICAL: AttachmentsStore cleanup prevents memory leaks (research Pitfall 2).
  </action>
  <verify>
Run TypeScript compiler:
```bash
npx tsc --noEmit
```

Check both stores export classes:
```bash
grep "export class" src/store/TestResultsStore.ts src/store/AttachmentsStore.ts
```

Verify Map usage for collections:
```bash
grep "Map<string" src/store/TestResultsStore.ts src/store/AttachmentsStore.ts
```
  </verify>
  <done>
- TestResultsStore.ts exists with Map-based collection and loading progress
- AttachmentsStore.ts exists with blob URL registry and cleanup method
- Both use makeAutoObservable and root store reference
- TestResultsStore has resultsList computed value
- AttachmentsStore extracts ID from filename and uses URL.createObjectURL
- TypeScript compilation succeeds
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate domain stores into RootStore</name>
  <files>
    src/store/index.tsx
  </files>
  <action>
Update RootStore to instantiate and coordinate domain stores:

**Changes to src/store/index.tsx:**

1. Import new stores:
```typescript
import { ReportStore } from './ReportStore'
import { TestResultsStore } from './TestResultsStore'
import { AttachmentsStore } from './AttachmentsStore'
```

2. Add child store properties to RootStore class:
```typescript
export class RootStore {
  reportStore: ReportStore
  testResultsStore: TestResultsStore
  attachmentsStore: AttachmentsStore

  // Existing properties
  isDockOpen = false

  constructor() {
    this.reportStore = new ReportStore(this)
    this.testResultsStore = new TestResultsStore(this)
    this.attachmentsStore = new AttachmentsStore(this)
    makeAutoObservable(this)
  }

  // Existing methods: openDock, closeDock
}
```

3. Add coordinating method for full report load:
```typescript
async loadReport(files: FileList): Promise<void> {
  const fileLoader = new FileLoaderService()
  const { runFile, resultFiles, attachmentFiles } =
    await fileLoader.loadReportDirectory(files)

  if (!runFile) {
    throw new Error('run.json not found in selected directory')
  }

  await this.reportStore.loadRun(runFile)
  await this.testResultsStore.loadResults(resultFiles)

  for (const file of attachmentFiles) {
    this.attachmentsStore.registerAttachment(file)
  }
}
```

Keep existing RootStoreContext, RootStoreProvider, and useRootStore exports unchanged.

Follow existing codebase pattern from current src/store/index.tsx structure.
  </action>
  <verify>
Run TypeScript compiler:
```bash
npx tsc --noEmit
```

Check RootStore has child stores:
```bash
grep "reportStore\|testResultsStore\|attachmentsStore" src/store/index.tsx
```

Verify imports:
```bash
grep "import.*ReportStore\|import.*TestResultsStore\|import.*AttachmentsStore" src/store/index.tsx
```
  </verify>
  <done>
- RootStore instantiates three domain stores in constructor
- RootStore has loadReport method coordinating file loading across stores
- All store imports added
- Existing RootStore functionality preserved (isDockOpen, openDock, closeDock)
- TypeScript compilation succeeds
- useRootStore hook still exported for component access
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Verify all store files exist:
```bash
ls src/store/ReportStore.ts src/store/TestResultsStore.ts src/store/AttachmentsStore.ts
```

2. Run full TypeScript check:
```bash
npx tsc --noEmit
```

3. Check RootStore integration:
```bash
grep -A 5 "constructor()" src/store/index.tsx | grep "reportStore\|testResultsStore\|attachmentsStore"
```

4. Verify makeAutoObservable usage in all stores:
```bash
grep -l "makeAutoObservable" src/store/*.ts
```

All checks should pass with no errors.
</verification>

<success_criteria>
- Three domain stores created: ReportStore, TestResultsStore, AttachmentsStore
- Each store follows MobX makeAutoObservable pattern from existing codebase
- ReportStore manages run.json data with loading/error states
- TestResultsStore manages Map of test results with progress tracking
- AttachmentsStore manages blob URLs with cleanup method
- RootStore instantiates child stores and provides loadReport coordinator method
- All stores use runInAction for async state mutations
- TypeScript compilation succeeds with no errors
- Stores ready for React component consumption via useRootStore hook
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-foundation/01-02-SUMMARY.md`
</output>
