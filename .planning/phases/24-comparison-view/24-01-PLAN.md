---
phase: 24-comparison-view
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/comparison.ts
  - src/store/AnalyticsStore.ts
autonomous: true

must_haves:
  truths:
    - "User can select two runs for comparison"
    - "Comparison data computed reactively when selections change"
    - "Tests grouped by change type (added, removed, changed)"
  artifacts:
    - path: "src/types/comparison.ts"
      provides: "ComparisonResult and TestDiff type definitions"
      exports: ["ComparisonResult", "TestDiff", "StatusChange", "DurationChange"]
    - path: "src/store/AnalyticsStore.ts"
      provides: "Comparison computed properties and selection state"
      contains: "selectedBaseRunId"
  key_links:
    - from: "src/store/AnalyticsStore.ts"
      to: "src/store/HistoryStore.ts"
      via: "getTestHistory and history.runs access"
      pattern: "this\\.root\\.historyStore"
---

<objective>
Add comparison computed properties to AnalyticsStore for reactive run comparison.

Purpose: Enable reactive computation of test differences between two historical runs using signature-based identity and Map-based O(n+m) diff algorithm.

Output: Comparison types and AnalyticsStore extensions ready for UI consumption.
</objective>

<execution_context>
@/Users/gda/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-comparison-view/24-RESEARCH.md

@src/store/AnalyticsStore.ts
@src/store/HistoryStore.ts
@src/schemas/QaseHistory.schema.ts
@src/types/gallery.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create comparison type definitions</name>
  <files>src/types/comparison.ts</files>
  <action>
Create comparison types following the pattern from src/types/gallery.ts:

```typescript
import type { HistoricalTestRunData, HistoricalRun } from '../schemas/QaseHistory.schema'

/** Status transition between runs (e.g., passed -> failed) */
export interface StatusChange {
  signature: string
  title: string
  oldStatus: 'passed' | 'failed' | 'skipped' | 'broken'
  newStatus: 'passed' | 'failed' | 'skipped' | 'broken'
  /** 'regression' if passed->failed, 'fixed' if failed->passed, 'other' otherwise */
  changeType: 'regression' | 'fixed' | 'other'
}

/** Duration change between runs */
export interface DurationChange {
  signature: string
  title: string
  oldDuration: number
  newDuration: number
  /** Difference in ms (positive = slower, negative = faster) */
  difference: number
  /** Percentage change (positive = slower, negative = faster) */
  percentChange: number
  /** true if change exceeds threshold (>20% or >500ms) */
  isSignificant: boolean
}

/** Test diff categories */
export interface TestDiff {
  /** Tests in compare run but not in base run */
  added: Array<{ signature: string; title: string; status: string; duration: number }>
  /** Tests in base run but not in compare run */
  removed: Array<{ signature: string; title: string; status: string; duration: number }>
  /** Tests with status changes */
  statusChanged: StatusChange[]
  /** Tests with significant duration changes */
  durationChanged: DurationChange[]
  /** Count of tests unchanged between runs */
  unchangedCount: number
}

/** Complete comparison result */
export interface ComparisonResult {
  baseRun: HistoricalRun
  compareRun: HistoricalRun
  diff: TestDiff
  /** Summary stats */
  summary: {
    totalBase: number
    totalCompare: number
    addedCount: number
    removedCount: number
    statusChangedCount: number
    durationChangedCount: number
    regressionCount: number
    fixedCount: number
  }
}

/** Helper to determine status change type */
export function getStatusChangeType(
  oldStatus: string,
  newStatus: string
): 'regression' | 'fixed' | 'other' {
  if (oldStatus === 'passed' && newStatus === 'failed') return 'regression'
  if (oldStatus === 'failed' && newStatus === 'passed') return 'fixed'
  return 'other'
}
```

Duration threshold: 20% or 500ms absolute (whichever is larger) - matches research recommendation for avoiding noise.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit src/types/comparison.ts`</verify>
  <done>comparison.ts exports ComparisonResult, TestDiff, StatusChange, DurationChange types and getStatusChangeType helper</done>
</task>

<task type="auto">
  <name>Task 2: Add comparison state and computed properties to AnalyticsStore</name>
  <files>src/store/AnalyticsStore.ts</files>
  <action>
Add to AnalyticsStore following the existing computed property pattern (see failureClusters, galleryAttachments):

1. Add imports at top:
```typescript
import type { ComparisonResult, TestDiff, StatusChange, DurationChange } from '../types/comparison'
import { getStatusChangeType } from '../types/comparison'
```

2. Add observable selection state after constructor:
```typescript
/** Selected base run ID for comparison (older run) */
selectedBaseRunId: string | null = null

/** Selected compare run ID for comparison (newer run) */
selectedCompareRunId: string | null = null
```

3. Add action methods:
```typescript
/** Sets the base run for comparison */
setSelectedBaseRunId = (runId: string | null) => {
  this.selectedBaseRunId = runId
}

/** Sets the compare run for comparison */
setSelectedCompareRunId = (runId: string | null) => {
  this.selectedCompareRunId = runId
}

/** Clears comparison selection */
clearComparisonSelection = () => {
  this.selectedBaseRunId = null
  this.selectedCompareRunId = null
}
```

4. Add computed property for comparison result:
```typescript
/**
 * Returns comparison result between two selected runs.
 * Uses Map-based O(n+m) algorithm for efficient diff computation.
 * Returns null if either run is not selected or not found.
 *
 * Computed property automatically updates when selections or history change.
 */
get comparison(): ComparisonResult | null {
  if (!this.selectedBaseRunId || !this.selectedCompareRunId) return null

  const history = this.root.historyStore.history
  if (!history) return null

  const baseRun = history.runs.find(r => r.run_id === this.selectedBaseRunId)
  const compareRun = history.runs.find(r => r.run_id === this.selectedCompareRunId)

  if (!baseRun || !compareRun) return null

  return this.computeComparison(baseRun, compareRun)
}

/**
 * Indicates whether a valid comparison is available.
 */
get hasComparison(): boolean {
  return this.comparison !== null
}

/**
 * Returns runs available for comparison selection.
 * Limited to most recent 20 runs for dropdown usability.
 */
get comparableRuns(): HistoricalRun[] {
  const history = this.root.historyStore.history
  if (!history) return []

  return [...history.runs]
    .sort((a, b) => b.start_time - a.start_time) // Most recent first
    .slice(0, 20)
}
```

5. Add private helper method for computing comparison:
```typescript
/**
 * Computes diff between two runs using Map-based set operations.
 * O(n+m) complexity where n=base tests, m=compare tests.
 *
 * @private
 */
private computeComparison(baseRun: HistoricalRun, compareRun: HistoricalRun): ComparisonResult {
  const history = this.root.historyStore.history!

  // Build Maps for O(1) lookup by signature
  const baseTestsMap = new Map<string, { signature: string; title: string; status: string; duration: number }>()
  const compareTestsMap = new Map<string, { signature: string; title: string; status: string; duration: number }>()

  for (const testEntry of history.tests) {
    const baseRunData = testEntry.runs.find(r => r.run_id === baseRun.run_id)
    const compareRunData = testEntry.runs.find(r => r.run_id === compareRun.run_id)

    if (baseRunData) {
      baseTestsMap.set(testEntry.signature, {
        signature: testEntry.signature,
        title: testEntry.title,
        status: baseRunData.status,
        duration: baseRunData.duration,
      })
    }

    if (compareRunData) {
      compareTestsMap.set(testEntry.signature, {
        signature: testEntry.signature,
        title: testEntry.title,
        status: compareRunData.status,
        duration: compareRunData.duration,
      })
    }
  }

  // Calculate diff
  const added: TestDiff['added'] = []
  const removed: TestDiff['removed'] = []
  const statusChanged: StatusChange[] = []
  const durationChanged: DurationChange[] = []
  let unchangedCount = 0

  // Find added tests (in compare but not in base)
  for (const [signature, test] of compareTestsMap) {
    if (!baseTestsMap.has(signature)) {
      added.push(test)
    }
  }

  // Find removed tests (in base but not in compare)
  for (const [signature, test] of baseTestsMap) {
    if (!compareTestsMap.has(signature)) {
      removed.push(test)
    }
  }

  // Find changed tests (in both)
  for (const [signature, baseTest] of baseTestsMap) {
    const compareTest = compareTestsMap.get(signature)
    if (!compareTest) continue

    let hasChange = false

    // Check status change
    if (baseTest.status !== compareTest.status) {
      hasChange = true
      statusChanged.push({
        signature,
        title: baseTest.title,
        oldStatus: baseTest.status as StatusChange['oldStatus'],
        newStatus: compareTest.status as StatusChange['newStatus'],
        changeType: getStatusChangeType(baseTest.status, compareTest.status),
      })
    }

    // Check duration change (significant = >20% or >500ms)
    const difference = compareTest.duration - baseTest.duration
    const percentChange = baseTest.duration > 0
      ? (difference / baseTest.duration) * 100
      : 0
    const isSignificant = Math.abs(percentChange) > 20 || Math.abs(difference) > 500

    if (isSignificant) {
      hasChange = true
      durationChanged.push({
        signature,
        title: baseTest.title,
        oldDuration: baseTest.duration,
        newDuration: compareTest.duration,
        difference,
        percentChange,
        isSignificant,
      })
    }

    if (!hasChange) {
      unchangedCount++
    }
  }

  // Build summary
  const regressionCount = statusChanged.filter(c => c.changeType === 'regression').length
  const fixedCount = statusChanged.filter(c => c.changeType === 'fixed').length

  return {
    baseRun,
    compareRun,
    diff: {
      added,
      removed,
      statusChanged,
      durationChanged,
      unchangedCount,
    },
    summary: {
      totalBase: baseTestsMap.size,
      totalCompare: compareTestsMap.size,
      addedCount: added.length,
      removedCount: removed.length,
      statusChangedCount: statusChanged.length,
      durationChangedCount: durationChanged.length,
      regressionCount,
      fixedCount,
    },
  }
}
```

6. Add import for HistoricalRun at top if not present:
```typescript
import type { HistoricalRun } from '../schemas/QaseHistory.schema'
```

Ensure makeAutoObservable in constructor captures the new observables and actions.
  </action>
  <verify>
TypeScript compiles: `npm run build` succeeds without errors.
Manual test: In browser console, access store via `__MOBX_DEVTOOLS__` or React DevTools, verify `analyticsStore.comparableRuns` returns array when history loaded.
  </verify>
  <done>AnalyticsStore has selectedBaseRunId/selectedCompareRunId observables, setSelectedBaseRunId/setSelectedCompareRunId/clearComparisonSelection actions, comparison/hasComparison/comparableRuns computed properties</done>
</task>

</tasks>

<verification>
1. `npm run build` completes without TypeScript errors
2. New types exported from src/types/comparison.ts
3. AnalyticsStore.comparison returns null when no runs selected
4. AnalyticsStore.comparableRuns returns up to 20 runs when history exists
</verification>

<success_criteria>
- ComparisonResult type defines baseRun, compareRun, diff, and summary
- TestDiff type has added, removed, statusChanged, durationChanged arrays
- AnalyticsStore.comparison computed property returns diff data when two runs selected
- AnalyticsStore.comparableRuns provides dropdown data limited to 20 runs
- Duration threshold uses 20% OR 500ms for significance detection
</success_criteria>

<output>
After completion, create `.planning/phases/24-comparison-view/24-01-SUMMARY.md`
</output>
