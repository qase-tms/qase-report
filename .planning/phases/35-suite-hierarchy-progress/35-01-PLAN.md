---
phase: 35-suite-hierarchy-progress
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/TestList/buildSuiteTree.ts
  - src/components/TestList/DataTable.tsx
  - src/components/TestList/columns.tsx
autonomous: true

must_haves:
  truths:
    - "Suite hierarchy displays as expandable rows in table"
    - "User can click chevron to expand/collapse suite"
    - "Tests appear nested under their parent suite"
    - "Suite rows show aggregate test count"
  artifacts:
    - path: "src/components/TestList/buildSuiteTree.ts"
      provides: "Tree transformation utility"
      exports: ["buildSuiteTree", "TreeNode"]
    - path: "src/components/TestList/DataTable.tsx"
      provides: "Expanding rows support"
      contains: "getExpandedRowModel"
    - path: "src/components/TestList/columns.tsx"
      provides: "Column with expand/collapse chevron"
      contains: "ChevronDown"
  key_links:
    - from: "src/components/TestList/index.tsx"
      to: "buildSuiteTree"
      via: "useMemo transformation"
      pattern: "buildSuiteTree\\(filteredResults\\)"
    - from: "src/components/TestList/DataTable.tsx"
      to: "getSubRows"
      via: "TanStack Table config"
      pattern: "getSubRows.*subRows"
---

<objective>
Create tree transformation utility and add expanding rows support to DataTable for suite hierarchy display.

Purpose: Transform flat test arrays into hierarchical tree structure with suites as parent rows and tests as children, enabling expandable row navigation in the data table.

Output: `buildSuiteTree.ts` utility, updated DataTable with `getExpandedRowModel`, columns with expand/collapse chevrons.
</objective>

<execution_context>
@/Users/gda/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/35-suite-hierarchy-progress/35-RESEARCH.md
@.planning/phases/34-tanstack-table-migration/34-02-SUMMARY.md
@.planning/phases/34-tanstack-table-migration/34-03-SUMMARY.md
@src/components/TestList/DataTable.tsx
@src/components/TestList/columns.tsx
@src/schemas/QaseTestResult.schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create buildSuiteTree utility function</name>
  <files>src/components/TestList/buildSuiteTree.ts</files>
  <action>
Create `buildSuiteTree.ts` that transforms flat QaseTestResult[] into TreeNode[] hierarchical structure.

**TreeNode type definition:**
```typescript
export type TreeNode = {
  id: string                    // Suite path or test ID
  type: 'suite' | 'test'        // Row type discriminator
  // Suite properties (only when type === 'suite')
  suitePath?: string[]          // Array of parent suite titles
  suiteTitle?: string           // Last suite title in path
  totalTests?: number           // Test count for suite
  passedCount?: number          // Aggregated passed count
  failedCount?: number          // Aggregated failed count
  skippedCount?: number         // Aggregated skipped count
  brokenCount?: number          // Aggregated broken count
  totalDuration?: number        // Sum of test durations
  // Test properties (only when type === 'test')
  testData?: QaseTestResult     // Original test data
  // TanStack Table requirement
  subRows?: TreeNode[]          // Children (tests for suite, empty for test)
}
```

**Implementation pattern (O(n) single pass):**
1. Create Map<string, TreeNode> for suites (keyed by path)
2. For each test in input array:
   - Get suite path from `test.relations?.suite?.data.map(s => s.title)` or `['No Suite']`
   - Create suite key by joining path with ' > '
   - If suite not in map, create new suite TreeNode with zero counts
   - Increment aggregate counts based on `test.execution.status`
   - Add test duration to `totalDuration`
   - Push test as TreeNode to suite's `subRows`
3. Return `Array.from(suiteMap.values())`

**Export:** Named export `buildSuiteTree` and `TreeNode` type.
  </action>
  <verify>
```bash
# Check file exists and exports correct symbols
grep -E "export (type TreeNode|function buildSuiteTree)" src/components/TestList/buildSuiteTree.ts

# Check TypeScript compiles
npx tsc --noEmit src/components/TestList/buildSuiteTree.ts
```
  </verify>
  <done>
- buildSuiteTree.ts exports `TreeNode` type and `buildSuiteTree` function
- Function transforms flat array to tree in O(n) time
- Suite nodes have aggregate counts (totalTests, passedCount, etc.)
- Test nodes have `testData` property with original QaseTestResult
  </done>
</task>

<task type="auto">
  <name>Task 2: Update DataTable with expanding state management</name>
  <files>src/components/TestList/DataTable.tsx</files>
  <action>
Update DataTable component to support expandable rows using TanStack Table's expanding feature.

**Add imports:**
```typescript
import {
  // ... existing imports
  getExpandedRowModel,
  type ExpandedState,
} from '@tanstack/react-table'
```

**Update DataTableProps interface:**
```typescript
interface DataTableProps<TData, TValue> {
  columns: ColumnDef<TData, TValue>[]
  data: TData[]
  onRowClick?: (row: TData) => void
  height?: number
  // NEW: Expanding support
  getSubRows?: (originalRow: TData) => TData[] | undefined
  getRowId?: (originalRow: TData) => string
  expanded?: ExpandedState
  onExpandedChange?: (updater: ExpandedState | ((old: ExpandedState) => ExpandedState)) => void
}
```

**Add expanding state:**
- If `expanded` prop not provided, use internal state: `const [internalExpanded, setInternalExpanded] = useState<ExpandedState>({})`
- Use controlled state pattern: `const expandedState = expanded ?? internalExpanded`

**Update useReactTable config:**
```typescript
const table = useReactTable({
  data,
  columns,
  state: {
    sorting,
    expanded: expandedState,  // NEW
  },
  onSortingChange: setSorting,
  onExpandedChange: onExpandedChange ?? setInternalExpanded,  // NEW
  getRowId: getRowId,         // NEW - stable row IDs
  getSubRows: getSubRows,     // NEW - children accessor
  getCoreRowModel: getCoreRowModel(),
  getSortedRowModel: getSortedRowModel(),
  getExpandedRowModel: getExpandedRowModel(),  // NEW
})
```

**Important:** Keep existing virtualization logic unchanged. Virtual rows will still work because we iterate over `rows` from `table.getRowModel()` which includes expanded rows.
  </action>
  <verify>
```bash
# Check expanding imports
grep "getExpandedRowModel" src/components/TestList/DataTable.tsx

# Check props interface
grep -A3 "interface DataTableProps" src/components/TestList/DataTable.tsx

# Build to verify TypeScript
npm run build 2>&1 | head -20
```
  </verify>
  <done>
- DataTable accepts `getSubRows`, `getRowId`, `expanded`, `onExpandedChange` props
- TanStack Table configured with `getExpandedRowModel()`
- Internal expanded state fallback when controlled props not provided
- Build completes without TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Add expand/collapse column to columns.tsx</name>
  <files>src/components/TestList/columns.tsx</files>
  <action>
Update columns to handle both suite and test rows with expand/collapse functionality.

**Add imports:**
```typescript
import { ChevronDown, ChevronRight, ArrowUpDown, MoreHorizontal, FolderOpen, File } from 'lucide-react'
import type { TreeNode } from './buildSuiteTree'
```

**Update createColumns signature:**
```typescript
export const createColumns = (
  onSelectTest: (id: string) => void
): ColumnDef<TreeNode>[] => [...]
```

**Replace 'id' column with 'name' column:**
Create combined name column showing suite/test with indentation and expand icon.

```typescript
{
  id: 'name',
  header: 'Name',
  cell: ({ row }) => {
    const canExpand = row.getCanExpand()
    const isExpanded = row.getIsExpanded()
    const isSuite = row.original.type === 'suite'

    return (
      <div
        className="flex items-center"
        style={{ paddingLeft: `${row.depth * 1.5}rem` }}
      >
        {/* Expand/collapse button for suites */}
        {canExpand ? (
          <button
            onClick={(e) => {
              e.stopPropagation()
              row.toggleExpanded()
            }}
            className="mr-2 p-1 hover:bg-accent rounded"
          >
            {isExpanded ? (
              <ChevronDown className="h-4 w-4" />
            ) : (
              <ChevronRight className="h-4 w-4" />
            )}
          </button>
        ) : (
          <span className="mr-2 w-6" /> // Spacing for leaf nodes
        )}

        {/* Icon for row type */}
        {isSuite ? (
          <FolderOpen className="h-4 w-4 mr-2 text-muted-foreground" />
        ) : (
          <File className="h-4 w-4 mr-2 text-muted-foreground" />
        )}

        {/* Name */}
        <span className={isSuite ? 'font-medium' : ''}>
          {isSuite ? row.original.suiteTitle : row.original.testData?.title}
        </span>

        {/* Test count badge for suites */}
        {isSuite && (
          <span className="ml-2 text-xs text-muted-foreground">
            ({row.original.totalTests} test{row.original.totalTests !== 1 ? 's' : ''})
          </span>
        )}
      </div>
    )
  },
},
```

**Update Status column to handle both types:**
- For suites: Show nothing or summary (handled in Plan 02 with progress bar)
- For tests: Show status icon as before

```typescript
{
  accessorKey: 'execution.status',
  // ... existing header
  cell: ({ row }) => {
    // Suites don't have status column (progress bar in Plan 02)
    if (row.original.type === 'suite') return null

    const status = row.original.testData?.execution.status
    if (!status) return null

    return (
      <div className="flex items-center gap-2">
        {getStatusIcon(status)}
        <span className="capitalize">{status}</span>
      </div>
    )
  },
  size: 120,
}
```

**Update Duration column:**
- For suites: Show total duration
- For tests: Show test duration

```typescript
cell: ({ row }) => {
  const duration = row.original.type === 'suite'
    ? row.original.totalDuration
    : row.original.testData?.execution.duration

  if (!duration) return null

  const durationText = duration >= 1000
    ? `${(duration / 1000).toFixed(1)}s`
    : `${duration}ms`

  return <div className="text-right">{durationText}</div>
}
```

**Update Actions column:**
- For suites: No actions
- For tests: Keep existing View details action

```typescript
cell: ({ row }) => {
  // No actions for suites
  if (row.original.type === 'suite') return null

  const test = row.original.testData
  if (!test) return null

  return (
    <DropdownMenu>
      {/* ... existing dropdown content, use test.id instead of row.original.id */}
    </DropdownMenu>
  )
}
```
  </action>
  <verify>
```bash
# Check TreeNode import
grep "import.*TreeNode.*buildSuiteTree" src/components/TestList/columns.tsx

# Check chevron imports
grep "ChevronDown.*ChevronRight" src/components/TestList/columns.tsx

# Check expand toggle implementation
grep "toggleExpanded" src/components/TestList/columns.tsx

# Build to verify
npm run build
```
  </verify>
  <done>
- Columns use TreeNode type instead of QaseTestResult
- Name column shows expand/collapse chevron, icon, title, and test count
- Status column handles both suite (null) and test rows
- Duration column shows totalDuration for suites, test duration for tests
- Actions column only shows for test rows
- Build completes without errors
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `npm run build` succeeds
2. buildSuiteTree utility: Transforms flat array to tree structure
3. DataTable: Has getExpandedRowModel and accepts expanding props
4. Columns: Has expand/collapse chevron with TreeNode type

Manual verification:
- Load test report
- See suites as parent rows
- Click chevron to expand/collapse
- Tests appear nested under suites
</verification>

<success_criteria>
- [ ] buildSuiteTree.ts exports TreeNode type and buildSuiteTree function
- [ ] DataTable accepts getSubRows, getRowId, expanded, onExpandedChange props
- [ ] Columns handle both suite and test row types
- [ ] Expand/collapse chevron toggles suite expansion
- [ ] npm run build passes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/35-suite-hierarchy-progress/35-01-SUMMARY.md`
</output>
