---
phase: 22-failure-clusters
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/store/AnalyticsStore.ts
autonomous: true

must_haves:
  truths:
    - "Failed tests are grouped by normalized error message"
    - "Each cluster contains 2+ tests with similar errors"
    - "Clusters are sorted by test count descending"
  artifacts:
    - path: "src/store/AnalyticsStore.ts"
      provides: "failureClusters computed property and normalizeErrorMessage helper"
      contains: "get failureClusters"
  key_links:
    - from: "src/store/AnalyticsStore.ts"
      to: "testResultsStore.resultsList"
      via: "MobX computed property dependency"
      pattern: "this\\.root\\.testResultsStore\\.resultsList"
---

<objective>
Add failure clustering algorithm to AnalyticsStore

Purpose: Enable grouping of failed tests by similar error messages so users can quickly identify common failure patterns across their test suite.

Output: `failureClusters` computed property returning array of `{ errorPattern: string; tests: QaseTestResult[] }` sorted by test count descending.
</objective>

<execution_context>
@/Users/gda/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/22-failure-clusters/22-RESEARCH.md

@src/store/AnalyticsStore.ts
@src/schemas/QaseTestResult.schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add FailureCluster type and normalizeErrorMessage helper</name>
  <files>src/store/AnalyticsStore.ts</files>
  <action>
Add type export at top of file after existing imports:

```typescript
/**
 * Represents a cluster of failed tests sharing similar error messages.
 */
export interface FailureCluster {
  /** Normalized error pattern (first 100 chars, lowercased, whitespace-normalized) */
  errorPattern: string
  /** Tests in this cluster */
  tests: QaseTestResult[]
}
```

Add private helper method to AnalyticsStore class (after existing private methods around line 291):

```typescript
/**
 * Normalizes an error message for clustering comparison.
 * Takes first 100 chars, normalizes whitespace and case.
 *
 * @param message - Raw error message or null
 * @returns Normalized string key for clustering
 * @private
 */
private normalizeErrorMessage(message: string | null): string {
  if (!message) return '__no_error__'

  return message
    .slice(0, 100)
    .toLowerCase()
    .trim()
    .replace(/\s+/g, ' ')
}
```

This follows the existing pattern from flakiness detection (lines 490-505) which already uses similar normalization for error message consistency analysis.
  </action>
  <verify>TypeScript compilation: `npx tsc --noEmit` passes with no errors</verify>
  <done>FailureCluster type exported, normalizeErrorMessage helper method exists in AnalyticsStore</done>
</task>

<task type="auto">
  <name>Task 2: Add failureClusters computed property</name>
  <files>src/store/AnalyticsStore.ts</files>
  <action>
Add computed getter to AnalyticsStore class (after gradeDistribution getter, around line 233):

```typescript
/**
 * Returns failed tests grouped by normalized error message similarity.
 * Only returns clusters with 2+ tests (single failures are not clusters).
 * Clusters are sorted by test count descending.
 *
 * Error extraction priority:
 * 1. test.message (user-friendly error)
 * 2. First line of execution.stacktrace (fallback)
 * 3. '__no_error__' (tests without error info)
 *
 * Computed property automatically updates when test results change.
 */
get failureClusters(): FailureCluster[] {
  const failedTests = this.root.testResultsStore.resultsList
    .filter(test => test.execution.status === 'failed')

  if (failedTests.length === 0) return []

  const clusters = new Map<string, QaseTestResult[]>()

  for (const test of failedTests) {
    // Extract error: prefer message, fallback to first stacktrace line
    const errorSource = test.message
      ?? test.execution.stacktrace?.split('\n')[0]
      ?? null

    const errorKey = this.normalizeErrorMessage(errorSource)

    if (!clusters.has(errorKey)) {
      clusters.set(errorKey, [])
    }
    clusters.get(errorKey)!.push(test)
  }

  // Convert to array, filter single-test "clusters", sort by count desc
  return Array.from(clusters.entries())
    .filter(([_, tests]) => tests.length >= 2)
    .map(([errorPattern, tests]) => ({ errorPattern, tests }))
    .sort((a, b) => b.tests.length - a.tests.length)
}
```

Also add convenience getters:

```typescript
/**
 * Returns count of failure clusters.
 * Useful for sidebar/dashboard badges.
 */
get failureClusterCount(): number {
  return this.failureClusters.length
}

/**
 * Indicates whether any failure clusters exist.
 */
get hasFailureClusters(): boolean {
  return this.failureClusters.length > 0
}
```
  </action>
  <verify>
1. TypeScript compilation: `npx tsc --noEmit` passes
2. Manual verification in browser console after loading a report with failures:
   - `rootStore.analyticsStore.failureClusters` returns array
   - Each cluster has `errorPattern` (string) and `tests` (array with 2+ items)
   - Clusters sorted by tests.length descending
  </verify>
  <done>
- failureClusters computed property returns FailureCluster[]
- failureClusterCount and hasFailureClusters convenience getters exist
- Only clusters with 2+ tests are included
- Clusters sorted by test count descending
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `npx tsc --noEmit`
2. Dev server runs: `npm run dev`
3. In browser console with a report containing multiple failed tests with similar errors:
   - `rootStore.analyticsStore.failureClusters.length` > 0
   - `rootStore.analyticsStore.failureClusters[0].tests.length` >= 2
   - All tests in each cluster have status === 'failed'
</verification>

<success_criteria>
- FailureCluster type is exported from AnalyticsStore.ts
- failureClusters computed property exists and returns array of clusters
- Each cluster contains tests grouped by normalized error message (first 100 chars, lowercase, whitespace-normalized)
- Single-test "clusters" are filtered out (only 2+ tests)
- Clusters sorted by test count descending
- MobX reactivity works (clusters update when test results change)
</success_criteria>

<output>
After completion, create `.planning/phases/22-failure-clusters/22-01-SUMMARY.md`
</output>
