---
phase: 34-tanstack-table-migration
plan: 02
type: execute
wave: 2
depends_on: ["34-01"]
files_modified:
  - src/components/TestList/columns.tsx
  - src/components/TestList/DataTable.tsx
  - src/components/TestList/index.tsx
autonomous: true

must_haves:
  truths:
    - Table displays test columns (ID, Status, Title, Duration)
    - All columns support sorting (click header to toggle asc/desc)
    - Clicking test row opens TestDetailsDrawer
    - Row actions dropdown shows "View details" option (functional) and "View history" label (placeholder - wires in Phase 35)
    - MobX filteredResults drive table data reactively
  artifacts:
    - path: src/components/TestList/columns.tsx
      provides: Column definitions with sorting headers
      exports: ["columns"]
      min_lines: 80
    - path: src/components/TestList/DataTable.tsx
      provides: Reusable DataTable component with sorting
      exports: ["DataTable"]
      min_lines: 60
    - path: src/components/TestList/index.tsx
      provides: TestList page integrating DataTable with MobX
      exports: ["default"]
      min_lines: 30
  key_links:
    - from: src/components/TestList/index.tsx
      to: testResultsStore.filteredResults
      via: MobX computed property
      pattern: "testResultsStore\\.filteredResults"
    - from: src/components/TestList/columns.tsx
      to: QaseTestResult type
      via: ColumnDef generic
      pattern: "ColumnDef<QaseTestResult>"
    - from: src/components/TestList/DataTable.tsx
      to: useReactTable
      via: TanStack Table hook
      pattern: "useReactTable"
---

<objective>
Create column definitions and basic DataTable component with sorting, consuming MobX filtered data.

Purpose: Replace react-window list-based UI with table-based UI showing sortable columns.
Output: Working data table with ID, Status, Title, Duration columns and row actions dropdown.
</objective>

<execution_context>
@/Users/gda/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/34-tanstack-table-migration/34-RESEARCH.md
@.planning/phases/34-tanstack-table-migration/34-01-SUMMARY.md
@src/components/TestList/VirtualizedTestList.tsx
@src/components/TestList/TestListItem.tsx
@src/components/TestList/statusIcon.tsx
@src/store/TestResultsStore.ts
@src/components/ui/table.tsx
@src/components/ui/dropdown-menu.tsx
@src/components/ui/button.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create column definitions with sorting headers</name>
  <files>src/components/TestList/columns.tsx</files>
  <action>
Create columns.tsx defining 5 columns for QaseTestResult type:

1. **ID column** (accessorKey: "id"):
   - Header: "ID" (no sorting, just label)
   - Size: 100px
   - Cell: plain text

2. **Status column** (accessorKey: "execution.status"):
   - Header: Button with ArrowUpDown icon, toggles sorting on click
   - Cell: icon + text using getStatusIcon() from statusIcon.tsx
   - Sortable

3. **Title column** (accessorKey: "title"):
   - Header: Button with ArrowUpDown icon, toggles sorting
   - Cell: plain text, truncate with ellipsis
   - Sortable
   - Flex: 1 (takes remaining space)

4. **Duration column** (accessorKey: "execution.duration"):
   - Header: Button with ArrowUpDown icon, toggles sorting
   - Cell: formatted as "X.Xs" if >=1000ms, else "Xms" (match TestListItem.tsx pattern)
   - Sortable
   - Size: 120px

5. **Actions column** (id: "actions"):
   - Header: empty
   - Cell: DropdownMenu with MoreHorizontal icon trigger
   - Menu items: "View details" (calls onSelectTest), "View history" (placeholder for Phase 35)
   - Size: 60px

Use Button variant="ghost" for sortable headers per shadcn data table pattern.

Import ColumnDef from @tanstack/react-table, QaseTestResult from schemas, getStatusIcon from ./statusIcon.tsx.

Export as: `export const columns: ColumnDef<QaseTestResult>[]`

Per research Pattern 1: Use column.toggleSorting(column.getIsSorted() === "asc") for sorting toggle. This is controlled sorting - DataTable will manage state.

AVOID anti-pattern: Do NOT define columns inline in component - export as constant to prevent infinite re-renders (research Pitfall 1).
  </action>
  <verify>
```bash
cat src/components/TestList/columns.tsx | grep -E "ColumnDef<QaseTestResult>|accessorKey.*execution\.status|toggleSorting|DropdownMenu"
```
File contains type-safe column definitions with sorting and actions.
  </verify>
  <done>columns.tsx exports ColumnDef array with 5 columns (ID, Status, Title, Duration, Actions), sortable headers use Button with toggleSorting, actions column has DropdownMenu</done>
</task>

<task type="auto">
  <name>Task 2: Create basic DataTable component with sorting (no virtualization yet)</name>
  <files>src/components/TestList/DataTable.tsx</files>
  <action>
Create generic DataTable component following shadcn/ui data table pattern:

**Props interface:**
```typescript
interface DataTableProps<TData, TValue> {
  columns: ColumnDef<TData, TValue>[]
  data: TData[]
  onRowClick?: (row: TData) => void
}
```

**Implementation:**
1. Use useState for sorting: `const [sorting, setSorting] = useState<SortingState>([])`
2. Use useReactTable with:
   - data, columns props
   - state: { sorting }
   - onSortingChange: setSorting
   - getCoreRowModel: getCoreRowModel()
   - getSortedRowModel: getSortedRowModel()
3. Render Table structure:
   - TableHeader with sticky positioning (className="sticky top-0 bg-background z-10")
   - TableBody with table.getRowModel().rows.map()
   - Use flexRender(header.column.columnDef.header, header.getContext()) for headers
   - Use flexRender(cell.column.columnDef.cell, cell.getContext()) for cells
   - TableRow with onClick={onRowClick} and hover styles (className="cursor-pointer hover:bg-accent")
4. Empty state: Show "No results." message when rows.length === 0

Wrap entire table in div with overflow-auto and border-radius.

Per research Pattern 2: This is basic table without virtualization (Plan 03 adds that). Height constraint will come from parent component.

Per research: Always pass getContext() to flexRender to avoid TypeScript errors (Pitfall 6).

AVOID anti-pattern: Do NOT use useMemo for data/columns here - they come from props, parent handles memoization (research Pattern 3).
  </action>
  <verify>
```bash
cat src/components/TestList/DataTable.tsx | grep -E "useReactTable|getSortedRowModel|flexRender|cursor-pointer"
```
Component uses TanStack Table hooks and renders interactive table.
  </verify>
  <done>DataTable.tsx exports generic component using useReactTable with sorting state, renders Table with sticky header and clickable rows</done>
</task>

<task type="auto">
  <name>Task 3: Create TestList page component integrating DataTable with MobX</name>
  <files>src/components/TestList/index.tsx</files>
  <action>
Refactor TestList/index.tsx to replace VirtualizedTestList with DataTable:

**Replace current implementation with:**
1. Import observer from mobx-react-lite
2. Import useRootStore hook
3. Import DataTable and columns
4. Import useMemo from react

**Component structure:**
```typescript
export default observer(() => {
  const { testResultsStore, selectTest } = useRootStore()

  // MobX provides filtered data reactively
  // Memoize to prevent table re-initialization on every render
  const data = useMemo(
    () => testResultsStore.filteredResults,
    [testResultsStore.filteredResults]
  )

  return (
    <div className="space-y-4">
      <TestListFilters />
      <TestListSearch />
      <DataTable
        columns={columns}
        data={data}
        onRowClick={(test) => selectTest(test.id)}
      />
    </div>
  )
})
```

Per research Pattern 3: MobX observer wrapper ensures component re-renders when filteredResults changes. useMemo creates stable reference for TanStack Table (required per research Pitfall 1 and Pitfall 3).

Per v1.5 migration strategy (STATE.md): MobX state management preserved - only UI layer changes. testResultsStore.filteredResults is source of truth, TanStack Table only handles sorting (not filtering).

REMOVE imports for:
- VirtualizedTestList (will delete in later cleanup task)
- Any suite grouping logic (deferred to Phase 35 per research Open Question #1)

Keep TestListFilters and TestListSearch components - they work with MobX, not TanStack state.

Note: This version doesn't have virtual scrolling yet (Plan 03 adds that). For now, render all rows - performance will be addressed next.
  </action>
  <verify>
```bash
cat src/components/TestList/index.tsx | grep -E "observer|testResultsStore\.filteredResults|DataTable|useMemo"
npm run build
```
Component uses MobX observer pattern with memoized data, build succeeds.
  </verify>
  <done>TestList/index.tsx exports observer component consuming testResultsStore.filteredResults via useMemo, renders DataTable with TestListFilters and TestListSearch above</done>
</task>

</tasks>

<verification>
1. Run `npm run dev` and load a test report
2. Verify table displays with 5 columns (ID, Status, Title, Duration, Actions)
3. Click Status column header - verify sort toggles (ascending → descending → unsorted)
4. Click Title column header - verify alphabetical sorting works
5. Click Duration column header - verify numerical sorting works
6. Click test row - verify TestDetailsDrawer opens
7. Click Actions dropdown (three dots) - verify menu shows "View details" and "View history"
8. Apply status filter - verify table updates reactively (MobX integration working)
</verification>

<success_criteria>
- [ ] columns.tsx exports 5 column definitions with proper TypeScript types
- [ ] DataTable.tsx renders interactive table with sorting
- [ ] TestList/index.tsx integrates DataTable with MobX filteredResults
- [ ] Clicking column headers toggles sorting (visible sort indicator)
- [ ] Clicking row opens TestDetailsDrawer
- [ ] Row actions dropdown displays and works
- [ ] Status/search filters update table reactively
- [ ] npm run dev works without console errors
</success_criteria>

<output>
After completion, create `.planning/phases/34-tanstack-table-migration/34-02-SUMMARY.md`
</output>
