---
phase: 11-regression-alerts
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/alerts.ts
  - src/store/AnalyticsStore.ts
autonomous: true

must_haves:
  truths:
    - "System detects performance regressions when duration > mean + 2*stddev"
    - "Regression detection requires minimum 5 runs for statistical validity"
    - "Alerts array contains both flakiness warnings and regression errors"
  artifacts:
    - path: "src/types/alerts.ts"
      provides: "AlertItem and AlertType definitions"
      exports: ["AlertItem", "AlertType", "AlertSeverity"]
    - path: "src/store/AnalyticsStore.ts"
      provides: "getPerformanceRegression method and alerts computed"
      exports: ["getPerformanceRegression"]
  key_links:
    - from: "src/store/AnalyticsStore.ts"
      to: "src/store/HistoryStore.ts"
      via: "getTestHistory for duration analysis"
      pattern: "getTestHistory\\(signature\\)"
    - from: "src/store/AnalyticsStore.ts"
      to: "src/types/alerts.ts"
      via: "import AlertItem type"
      pattern: "import.*AlertItem.*from"
---

<objective>
Implement 2-sigma outlier detection for performance regressions in AnalyticsStore.

Purpose: Detect when test duration exceeds statistical normal range, indicating potential performance issues.
Output: AlertItem type definitions + getPerformanceRegression() method + alerts computed property
</objective>

<execution_context>
@/Users/gda/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-flakiness-detection/10-01-SUMMARY.md

@src/types/flakiness.ts
@src/store/AnalyticsStore.ts
@src/store/HistoryStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create alert types</name>
  <files>src/types/alerts.ts</files>
  <action>
Create type definitions for alerts system:

```typescript
/**
 * Alert severity levels - maps to MUI color palette
 */
export type AlertSeverity = 'warning' | 'error' | 'info'

/**
 * Alert type categories
 */
export type AlertType =
  | 'performance_regression' // Duration > mean + 2*stddev
  | 'flaky_warning'          // From flakiness detection
  | 'new_failure'            // From flakiness detection

/**
 * Single alert item for display
 */
export interface AlertItem {
  /** Unique identifier */
  id: string
  /** Alert category */
  type: AlertType
  /** Display severity */
  severity: AlertSeverity
  /** Test signature for navigation */
  testSignature: string
  /** Test title for display */
  testTitle: string
  /** Human-readable message */
  message: string
  /** Additional context (e.g., duration stats) */
  details?: {
    currentDuration?: number
    meanDuration?: number
    stdDev?: number
    threshold?: number
  }
}

/**
 * Minimum runs required for regression detection (same as flakiness)
 */
export const MIN_RUNS_REGRESSION = 5
```
  </action>
  <verify>npx tsc --noEmit</verify>
  <done>AlertItem, AlertType, AlertSeverity types exported from src/types/alerts.ts</done>
</task>

<task type="auto">
  <name>Task 2: Implement regression detection algorithm</name>
  <files>src/store/AnalyticsStore.ts</files>
  <action>
Add getPerformanceRegression method to AnalyticsStore:

1. Import types: `import { AlertItem, MIN_RUNS_REGRESSION } from '../types/alerts'`

2. Add helper method for statistics:
```typescript
/**
 * Calculates mean and standard deviation for an array of numbers
 * @private
 */
private calculateStats(values: number[]): { mean: number; stdDev: number } {
  const n = values.length
  if (n === 0) return { mean: 0, stdDev: 0 }

  const mean = values.reduce((sum, v) => sum + v, 0) / n
  const squaredDiffs = values.map(v => (v - mean) ** 2)
  const variance = squaredDiffs.reduce((sum, v) => sum + v, 0) / n
  const stdDev = Math.sqrt(variance)

  return { mean, stdDev }
}
```

3. Add regression detection method:
```typescript
/**
 * Detects performance regression for a test using 2-sigma outlier detection.
 * A regression is detected when the most recent duration exceeds mean + 2*stdDev.
 *
 * @param signature - Test signature to analyze
 * @returns Object with isRegression flag and stats, or null if insufficient data
 */
getPerformanceRegression(signature: string): {
  isRegression: boolean
  currentDuration: number
  meanDuration: number
  stdDev: number
  threshold: number
} | null {
  const runs = this.root.historyStore.getTestHistory(signature)

  // Require minimum runs for statistical validity
  if (runs.length < MIN_RUNS_REGRESSION) {
    return null
  }

  // Sort chronologically, get durations
  const sortedRuns = [...runs].sort((a, b) => a.start_time - b.start_time)
  const durations = sortedRuns.map(r => r.duration)

  // Calculate stats from all BUT the most recent run (to compare against)
  const historicalDurations = durations.slice(0, -1)
  const { mean, stdDev } = this.calculateStats(historicalDurations)

  // Current (most recent) duration
  const currentDuration = durations[durations.length - 1]

  // 2-sigma threshold
  const threshold = mean + 2 * stdDev

  // Detect regression
  const isRegression = currentDuration > threshold && stdDev > 0

  return {
    isRegression,
    currentDuration,
    meanDuration: Math.round(mean),
    stdDev: Math.round(stdDev),
    threshold: Math.round(threshold),
  }
}
```

Note: We compare against historical durations (excluding current) to detect if the LATEST run is an outlier. stdDev > 0 check prevents false positives when all durations are identical.
  </action>
  <verify>npx tsc --noEmit</verify>
  <done>getPerformanceRegression(signature) returns regression analysis with 2-sigma detection</done>
</task>

<task type="auto">
  <name>Task 3: Add alerts computed property</name>
  <files>src/store/AnalyticsStore.ts</files>
  <action>
Add computed property that aggregates all alerts:

```typescript
/**
 * Returns all alerts (flakiness + regressions) for dashboard display.
 * Alerts are sorted by severity (error first, then warning).
 *
 * Computed property automatically updates when history data changes.
 */
get alerts(): AlertItem[] {
  const history = this.root.historyStore.history
  if (!history || history.tests.length === 0) return []

  const alerts: AlertItem[] = []

  for (const test of history.tests) {
    const signature = test.signature

    // Check flakiness (existing logic)
    const flakiness = this.getFlakinessScore(signature)

    if (flakiness.status === 'flaky') {
      alerts.push({
        id: `flaky-${signature}`,
        type: 'flaky_warning',
        severity: 'warning',
        testSignature: signature,
        testTitle: test.title,
        message: `Flaky in ${flakiness.statusChanges} of ${flakiness.totalRuns} runs (${flakiness.flakinessPercent}%)`,
      })
    } else if (flakiness.status === 'new_failure') {
      alerts.push({
        id: `new-failure-${signature}`,
        type: 'new_failure',
        severity: 'error',
        testSignature: signature,
        testTitle: test.title,
        message: `Started failing after ${flakiness.totalRuns - 1} stable runs`,
      })
    }

    // Check performance regression
    const regression = this.getPerformanceRegression(signature)
    if (regression?.isRegression) {
      const pctIncrease = Math.round(
        ((regression.currentDuration - regression.meanDuration) / regression.meanDuration) * 100
      )
      alerts.push({
        id: `regression-${signature}`,
        type: 'performance_regression',
        severity: 'error',
        testSignature: signature,
        testTitle: test.title,
        message: `Duration ${pctIncrease}% above normal (${regression.currentDuration}ms vs ${regression.meanDuration}ms avg)`,
        details: {
          currentDuration: regression.currentDuration,
          meanDuration: regression.meanDuration,
          stdDev: regression.stdDev,
          threshold: regression.threshold,
        },
      })
    }
  }

  // Sort: errors first, then warnings
  return alerts.sort((a, b) => {
    if (a.severity === 'error' && b.severity !== 'error') return -1
    if (a.severity !== 'error' && b.severity === 'error') return 1
    return 0
  })
}

/**
 * Returns count of alerts for dashboard badge display.
 */
get alertCount(): number {
  return this.alerts.length
}

/**
 * Indicates whether any alerts exist.
 */
get hasAlerts(): boolean {
  return this.alerts.length > 0
}
```
  </action>
  <verify>npx tsc --noEmit</verify>
  <done>alerts computed returns sorted array of AlertItem with flakiness and regression alerts</done>
</task>

</tasks>

<verification>
```bash
# TypeScript compilation
npx tsc --noEmit

# Verify exports exist
grep -q "export.*AlertItem" src/types/alerts.ts && echo "AlertItem exported"
grep -q "export.*AlertType" src/types/alerts.ts && echo "AlertType exported"
grep -q "getPerformanceRegression" src/store/AnalyticsStore.ts && echo "getPerformanceRegression exists"
grep -q "get alerts" src/store/AnalyticsStore.ts && echo "alerts computed exists"
```
</verification>

<success_criteria>
- src/types/alerts.ts exports AlertItem, AlertType, AlertSeverity
- AnalyticsStore.getPerformanceRegression(signature) returns 2-sigma analysis
- AnalyticsStore.alerts computed returns array of AlertItem
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/11-regression-alerts/11-01-SUMMARY.md`
</output>
