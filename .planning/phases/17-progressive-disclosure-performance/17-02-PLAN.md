---
phase: 17-progressive-disclosure-performance
plan: 02
type: execute
wave: 2
depends_on: ["17-01"]
files_modified:
  - package.json
  - src/hooks/useScrollPosition.ts
  - src/components/TestList/VirtualizedTestList.tsx
  - src/components/TestList/index.tsx
autonomous: true

must_haves:
  truths:
    - "Test list with 500 tests scrolls without visible lag"
    - "Only visible test items are rendered in DOM (virtualization)"
    - "Scroll position is preserved when switching between views"
    - "Suite expand/collapse works correctly with virtual scrolling"
  artifacts:
    - path: "src/hooks/useScrollPosition.ts"
      provides: "Scroll position tracking with sessionStorage persistence"
      exports: ["useScrollPosition"]
    - path: "src/components/TestList/VirtualizedTestList.tsx"
      provides: "react-window virtualized list for grouped tests"
      contains: "VariableSizeList"
    - path: "package.json"
      provides: "react-window dependency"
      contains: "react-window"
  key_links:
    - from: "src/components/TestList/VirtualizedTestList.tsx"
      to: "react-window"
      via: "VariableSizeList import"
      pattern: "from 'react-window'"
    - from: "src/components/TestList/VirtualizedTestList.tsx"
      to: "src/hooks/useScrollPosition.ts"
      via: "hook usage for scroll preservation"
      pattern: "useScrollPosition"
    - from: "src/components/TestList/index.tsx"
      to: "src/components/TestList/VirtualizedTestList.tsx"
      via: "conditional render for large lists"
      pattern: "VirtualizedTestList"
---

<objective>
Implement virtual scrolling for test list performance at scale (500+ tests)

Purpose: Performance optimization - render only visible items to eliminate lag with large datasets. Addresses PERF-01 requirement and scroll position preservation.
Output: VirtualizedTestList component using react-window, useScrollPosition hook, seamless integration with existing TestList
</objective>

<execution_context>
@/Users/gda/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-progressive-disclosure-performance/17-RESEARCH.md
@.planning/phases/17-progressive-disclosure-performance/17-01-SUMMARY.md

@src/components/TestList/index.tsx
@src/components/TestList/SuiteGroup.tsx
@src/components/TestList/TestListItem.tsx
@src/hooks/useSuiteExpandState.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install react-window and create useScrollPosition hook</name>
  <files>package.json, src/hooks/useScrollPosition.ts</files>
  <action>
Install react-window dependency and create scroll position hook.

Step 1 - Install dependency:
```bash
npm install react-window@^1.8.10
npm install --save-dev @types/react-window
```

Step 2 - Create useScrollPosition hook:
Hook that saves scroll position to sessionStorage on scroll (debounced) and restores on mount.

Implementation from research:
```typescript
import { useEffect, useLayoutEffect, RefObject } from 'react'

export const useScrollPosition = (key: string, elementRef: RefObject<HTMLElement | null>) => {
  // Restore on mount (useLayoutEffect prevents flash)
  useLayoutEffect(() => {
    const element = elementRef.current
    if (!element) return

    const savedPosition = sessionStorage.getItem(`scroll-${key}`)
    if (savedPosition) {
      element.scrollTop = parseInt(savedPosition, 10)
    }
  }, [key, elementRef])

  // Save on scroll (debounced) and unmount
  useEffect(() => {
    const element = elementRef.current
    if (!element) return

    let timeoutId: ReturnType<typeof setTimeout>
    const handleScroll = () => {
      clearTimeout(timeoutId)
      timeoutId = setTimeout(() => {
        sessionStorage.setItem(`scroll-${key}`, element.scrollTop.toString())
      }, 100)
    }

    element.addEventListener('scroll', handleScroll)
    return () => {
      clearTimeout(timeoutId)
      element.removeEventListener('scroll', handleScroll)
      sessionStorage.setItem(`scroll-${key}`, element.scrollTop.toString())
    }
  }, [key, elementRef])
}
```

Use `ReturnType<typeof setTimeout>` for cross-environment compatibility (Node/browser).
  </action>
  <verify>
`npm install` completes successfully
`npm run build` compiles without errors
react-window and @types/react-window in package.json
useScrollPosition hook exports correctly
  </verify>
  <done>
react-window installed, useScrollPosition hook created with debounced save and restore functionality
  </done>
</task>

<task type="auto">
  <name>Task 2: Create VirtualizedTestList component</name>
  <files>src/components/TestList/VirtualizedTestList.tsx</files>
  <action>
Create virtualized test list component using react-window VariableSizeList with flattened grouped data.

Implementation approach:
1. Flatten grouped data into array of {type: 'suite-header' | 'test-item', data, suiteTitle}
2. Use VariableSizeList with variable heights: suite header 48px, test item 72px
3. Row renderer dispatches to SuiteHeader or TestListItem based on type
4. Integrate with expandedSuites and toggleSuite from parent
5. Use overscanCount=2 for smooth expand/collapse
6. Call listRef.resetAfterIndex(0) when expandedSuites changes

Types:
```typescript
interface FlatListItem {
  type: 'suite-header' | 'test-item'
  id: string
  data: { title: string; count: number } | QaseTestResult
  suiteTitle: string
}

interface VirtualizedTestListProps {
  grouped: Map<string, QaseTestResult[]>
  expandedSuites: Set<string>
  toggleSuite: (title: string) => void
  onSelectTest: (id: string) => void
  height: number
}
```

Flatten function (memoized):
```typescript
const flattenGroupedTests = (
  grouped: Map<string, QaseTestResult[]>,
  expandedSuites: Set<string>
): FlatListItem[] => {
  const flat: FlatListItem[] = []

  for (const [suiteTitle, tests] of grouped.entries()) {
    flat.push({
      type: 'suite-header',
      id: `suite-${suiteTitle}`,
      data: { title: suiteTitle, count: tests.length },
      suiteTitle
    })

    if (expandedSuites.has(suiteTitle)) {
      tests.forEach(test => {
        flat.push({
          type: 'test-item',
          id: test.id,
          data: test,
          suiteTitle
        })
      })
    }
  }

  return flat
}
```

Row renderer with MobX observer:
```typescript
const Row = observer(({ index, style, data }: ListChildComponentProps<RowData>) => {
  const { items, toggleSuite, onSelectTest } = data
  const item = items[index]
  const prefersReducedMotion = usePrefersReducedMotion()

  if (item.type === 'suite-header') {
    const headerData = item.data as { title: string; count: number }
    const isExpanded = data.expandedSuites.has(item.suiteTitle)
    const contentId = `suite-${encodeURIComponent(item.suiteTitle)}-content`

    return (
      <div style={style}>
        <ListItemButton
          onClick={() => toggleSuite(item.suiteTitle)}
          sx={{ bgcolor: 'action.hover' }}
          aria-expanded={isExpanded}
          aria-controls={contentId}
        >
          <ListItemText
            primary={headerData.title}
            secondary={`${headerData.count} test${headerData.count !== 1 ? 's' : ''}`}
          />
          {isExpanded ? <ExpandLess /> : <ExpandMore />}
        </ListItemButton>
      </div>
    )
  }

  return (
    <div style={style}>
      <TestListItem test={item.data as QaseTestResult} onSelect={onSelectTest} />
    </div>
  )
})
```

Main component:
```typescript
export const VirtualizedTestList = observer(({
  grouped,
  expandedSuites,
  toggleSuite,
  onSelectTest,
  height
}: VirtualizedTestListProps) => {
  const listRef = useRef<VariableSizeList>(null)

  const flatItems = useMemo(
    () => flattenGroupedTests(grouped, expandedSuites),
    [grouped, expandedSuites]
  )

  // Reset size cache when expanded state changes
  useEffect(() => {
    listRef.current?.resetAfterIndex(0)
  }, [expandedSuites])

  const getItemSize = (index: number) => {
    return flatItems[index].type === 'suite-header' ? 48 : 72
  }

  const itemData: RowData = {
    items: flatItems,
    expandedSuites,
    toggleSuite,
    onSelectTest
  }

  return (
    <VariableSizeList
      ref={listRef}
      height={height}
      itemCount={flatItems.length}
      itemSize={getItemSize}
      width="100%"
      overscanCount={2}
      itemData={itemData}
    >
      {Row}
    </VariableSizeList>
  )
})
```

CRITICAL: Apply `style` prop to root div in Row renderer - react-window requires this for positioning.
  </action>
  <verify>
`npm run build` compiles without TypeScript errors
VirtualizedTestList component renders suite headers and test items
  </verify>
  <done>
VirtualizedTestList component using react-window VariableSizeList with flattened grouped data, observer-wrapped row renderer
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate VirtualizedTestList into TestList</name>
  <files>src/components/TestList/index.tsx</files>
  <action>
Replace direct SuiteGroup rendering with VirtualizedTestList component.

Changes:
1. Import VirtualizedTestList
2. Import useScrollPosition hook
3. Create ref for scroll container
4. Add useScrollPosition('test-list', containerRef)
5. Replace grouped List with VirtualizedTestList
6. Calculate available height for list (use CSS calc or fixed value)

Updated TestList structure:
```tsx
export const TestList = observer(() => {
  const { testResultsStore, selectTest } = useRootStore()
  const { filteredResults, resultsList, activeFilterCount } = testResultsStore
  const { expandedSuites, toggleSuite } = useSuiteExpandState()
  const containerRef = useRef<HTMLDivElement>(null)

  useScrollPosition('test-list', containerRef)

  // ... early return and filter summary unchanged ...

  const grouped = groupBySuite(filteredResults)

  return (
    <Paper sx={{ p: 2 }}>
      {/* ... header, filters, summary unchanged ... */}

      {/* Virtualized test list */}
      <Box
        ref={containerRef}
        sx={{ height: 'calc(100vh - 400px)', minHeight: 300 }}
      >
        <VirtualizedTestList
          grouped={grouped}
          expandedSuites={expandedSuites}
          toggleSuite={toggleSuite}
          onSelectTest={selectTest}
          height={/* from containerRef.offsetHeight or fixed */}
        />
      </Box>
    </Paper>
  )
})
```

Height calculation: Use `containerRef.current?.offsetHeight || 400` as fallback. Could also use ResizeObserver for dynamic height, but fixed calculation is simpler for MVP.

Alternative approach: Pass height as CSS string and use AutoSizer from react-virtualized-auto-sizer if dynamic sizing needed. For now, use fixed calc value.
  </action>
  <verify>
`npm run build` compiles without errors
`npm run dev` - load report, verify:
  - Test list renders with virtualization (inspect DOM - only visible items present)
  - Scrolling is smooth with large datasets
  - Suite expand/collapse works correctly
  - Scroll position preserved when switching views
Performance test:
  - Create test with 500 items
  - Verify no visible lag when scrolling
  </verify>
  <done>
TestList uses VirtualizedTestList, scroll position persists, virtualization active for performance
  </done>
</task>

</tasks>

<verification>
1. Build succeeds: `npm run build`
2. Performance verification:
   - Load report with many tests
   - Open DevTools Performance tab
   - Scroll rapidly through list
   - No frame drops below 30fps
3. DOM verification:
   - Inspect list container
   - Only ~10-15 items rendered regardless of total count
4. Scroll position test:
   - Scroll to middle of list
   - Switch to test details view
   - Return to list view
   - Scroll position maintained
5. Accessibility: aria-expanded still works on suite headers
</verification>

<success_criteria>
- react-window dependency installed and types available
- Test list with 500 tests scrolls without visible lag
- DOM contains only rendered items (not all 500)
- Scroll position preserved when navigating away and back
- Suite expand/collapse works correctly within virtual list
- No TypeScript errors in build
</success_criteria>

<output>
After completion, create `.planning/phases/17-progressive-disclosure-performance/17-02-SUMMARY.md`
</output>
