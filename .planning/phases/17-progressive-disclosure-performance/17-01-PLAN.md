---
phase: 17-progressive-disclosure-performance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/TestList/SuiteGroup.tsx
  - src/hooks/useSuiteExpandState.ts
  - src/components/TestList/index.tsx
autonomous: true

must_haves:
  truths:
    - "Test suites are collapsed by default when TestList renders"
    - "User can click suite header to expand/collapse suite"
    - "Expanded suite state persists in sessionStorage"
    - "Screen readers announce expand/collapse state via aria-expanded"
  artifacts:
    - path: "src/hooks/useSuiteExpandState.ts"
      provides: "Suite expand state management with sessionStorage persistence"
      exports: ["useSuiteExpandState"]
    - path: "src/components/TestList/SuiteGroup.tsx"
      provides: "Collapsible suite group with ARIA accessibility"
      contains: "aria-expanded"
    - path: "src/components/TestList/index.tsx"
      provides: "TestList with lifted expand state management"
      contains: "useSuiteExpandState"
  key_links:
    - from: "src/components/TestList/index.tsx"
      to: "src/hooks/useSuiteExpandState.ts"
      via: "hook import and usage"
      pattern: "useSuiteExpandState"
    - from: "src/components/TestList/SuiteGroup.tsx"
      to: "sessionStorage"
      via: "isExpanded prop from parent"
      pattern: "isExpanded.*onToggle"
---

<objective>
Implement default-collapsed test suites with persistent expand state and accessibility

Purpose: Progressive disclosure - users see suite list overview first, then drill into specific suites. Addresses DISC-01 requirement.
Output: SuiteGroup collapsed by default, expand state persisted in sessionStorage, ARIA attributes for screen readers
</objective>

<execution_context>
@/Users/gda/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gda/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-progressive-disclosure-performance/17-RESEARCH.md

@src/components/TestList/index.tsx
@src/components/TestList/SuiteGroup.tsx
@src/hooks/usePrefersReducedMotion.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useSuiteExpandState hook</name>
  <files>src/hooks/useSuiteExpandState.ts</files>
  <action>
Create a custom React hook for managing suite expand/collapse state with sessionStorage persistence.

Implementation:
1. Storage key: `qase-report-expanded-suites`
2. State: `Set<string>` of expanded suite titles
3. Initialize from sessionStorage on mount (default: empty Set = all collapsed)
4. Persist to sessionStorage on change via useEffect
5. Expose `expandedSuites: Set<string>` and `toggleSuite: (title: string) => void`

Pattern from research:
```typescript
const STORAGE_KEY = 'qase-report-expanded-suites'

export const useSuiteExpandState = () => {
  const [expandedSuites, setExpandedSuites] = useState<Set<string>>(() => {
    const stored = sessionStorage.getItem(STORAGE_KEY)
    return stored ? new Set(JSON.parse(stored)) : new Set()
  })

  useEffect(() => {
    sessionStorage.setItem(STORAGE_KEY, JSON.stringify([...expandedSuites]))
  }, [expandedSuites])

  const toggleSuite = (suiteTitle: string) => {
    setExpandedSuites(prev => {
      const next = new Set(prev)
      if (next.has(suiteTitle)) {
        next.delete(suiteTitle)
      } else {
        next.add(suiteTitle)
      }
      return next
    })
  }

  return { expandedSuites, toggleSuite }
}
```

Handle SSR gracefully: check for `typeof window !== 'undefined'` before accessing sessionStorage in initializer.
  </action>
  <verify>
TypeScript compiles without errors: `npm run build`
Hook file exports useSuiteExpandState function
  </verify>
  <done>
useSuiteExpandState hook exists with expandedSuites Set and toggleSuite function, persists to sessionStorage
  </done>
</task>

<task type="auto">
  <name>Task 2: Update SuiteGroup for controlled collapse with ARIA</name>
  <files>src/components/TestList/SuiteGroup.tsx</files>
  <action>
Refactor SuiteGroup from internal state to controlled component pattern.

Changes:
1. Remove internal `useState(true)` for open state
2. Add props: `isExpanded: boolean` and `onToggle: () => void`
3. Add ARIA accessibility attributes to ListItemButton:
   - `aria-expanded={isExpanded}`
   - `aria-controls={contentId}` where contentId = `suite-${suiteTitle}-content`
4. Add `id` to Collapse component matching aria-controls
5. Keep existing `unmountOnExit` on Collapse (already present for performance)
6. Keep existing `usePrefersReducedMotion` for animation timeout

Updated props interface:
```typescript
interface SuiteGroupProps {
  suiteTitle: string
  tests: QaseTestResult[]
  onSelectTest: (id: string) => void
  isExpanded: boolean      // NEW: controlled expand state
  onToggle: () => void     // NEW: callback to toggle
}
```

ARIA pattern from research:
```tsx
<ListItemButton
  onClick={onToggle}
  sx={{ bgcolor: 'action.hover' }}
  aria-expanded={isExpanded}
  aria-controls={`suite-${encodeURIComponent(suiteTitle)}-content`}
>
  ...
</ListItemButton>
<Collapse
  in={isExpanded}
  timeout={prefersReducedMotion ? 0 : 'auto'}
  unmountOnExit
  id={`suite-${encodeURIComponent(suiteTitle)}-content`}
>
  ...
</Collapse>
```

Use encodeURIComponent for suiteTitle in IDs to handle special characters.
  </action>
  <verify>
TypeScript compiles without errors: `npm run build`
SuiteGroup accepts isExpanded and onToggle props
aria-expanded and aria-controls attributes present in component
  </verify>
  <done>
SuiteGroup is a controlled component with ARIA accessibility attributes for screen readers
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate expand state into TestList</name>
  <files>src/components/TestList/index.tsx</files>
  <action>
Connect useSuiteExpandState hook to TestList and pass state down to SuiteGroup components.

Changes:
1. Import useSuiteExpandState from hooks
2. Call hook at component level: `const { expandedSuites, toggleSuite } = useSuiteExpandState()`
3. Pass isExpanded and onToggle to each SuiteGroup:

```tsx
{Array.from(grouped.entries()).map(([suite, tests]) => (
  <SuiteGroup
    key={suite}
    suiteTitle={suite}
    tests={tests}
    onSelectTest={selectTest}
    isExpanded={expandedSuites.has(suite)}
    onToggle={() => toggleSuite(suite)}
  />
))}
```

This lifts state to TestList level, preparing for Plan 02 (virtual scrolling needs centralized expand state to calculate visible items).

Default behavior verification: With empty Set from sessionStorage, `expandedSuites.has(suite)` returns false, so all suites start collapsed.
  </action>
  <verify>
`npm run build` completes without errors
`npm run dev` - load a report with multiple suites, verify:
  - All suites start collapsed (only headers visible)
  - Clicking a suite header expands it
  - Clicking again collapses it
  - Refresh page - expanded suites remain expanded (sessionStorage)
  </verify>
  <done>
Test suites collapsed by default, expand state persists across page refresh, ARIA attributes work for accessibility
  </done>
</task>

</tasks>

<verification>
1. Build succeeds: `npm run build`
2. Functional test:
   - Load report with 3+ suites
   - Verify all suites collapsed on initial load
   - Expand first and third suite
   - Refresh page
   - First and third suite should still be expanded
3. Accessibility check: Inspect DOM, verify aria-expanded="true"/"false" on suite headers
</verification>

<success_criteria>
- Test suites collapsed by default when TestList renders
- Clicking suite header toggles expand/collapse
- Expanded state persists in sessionStorage (survives refresh)
- aria-expanded attribute present on all suite headers
- Screen readers can announce collapse state
</success_criteria>

<output>
After completion, create `.planning/phases/17-progressive-disclosure-performance/17-01-SUMMARY.md`
</output>
